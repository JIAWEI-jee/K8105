C51 COMPILER V9.56.0.0   UART                                                              11/02/2020 19:34:56 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: C:\program_list\keil\C51\BIN\C51.EXE ..\hardware\Uart\uart.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(
                    -..\hardware\DELAY;..\hardware\ADC;..\hardware\Flash;..\hardware\Uart;..\hardware\Key;..\hardware\Pwm;..\hardware\WDT;..\
                    -hardware\Timer;..\hardware\LCDdisplay;..\hardware\PID;..\hardware\TUYA) DEBUG OBJECTEXTEND PRINT(.\Listings\uart.lst) TA
                    -BS(2) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include "uart.h"
   2          #include "key.h"
   3          #include "wifi.h"
   4          
   5           volatile u8 usart_rx_buffer[30] = {0};
   6           volatile u8 usart_rx_cnt;
   7           u8 usart_rx_flag = 0;
   8           
   9          u8 temper_val = 0;
  10          
  11          
  12          #define PRODUCTE_CMD_HEADER_VALUE                   0x55
  13          #define PRODUCTE_CMD_TAIL1_VALUE                    0x0D
  14          #define PRODUCTE_CMD_TAIL2_VALUE                    0x0A
  15          
  16          
  17          struct producte_cmd_struct
  18          {
  19              u8 header;
  20              u8 funcode;
  21              u8 Data;
  22              u8 tail1;
  23              u8 tail2;
  24          };
  25          
  26          
  27          
  28          //初始化串口9600
  29          void uart_init(void)
  30          {
  31   1        //#if _DEBUG_PRINTF_
  32   1        P2M6 =  0xC1;   //P26设置为推挽输出   0xC1
  33   1        P2M5 = 0x60;    //P25设置为上拉输入 0x60
  34   1        TXD_MAP = 0x26;   //TXD映射P26
  35   1        RXD_MAP = 0x25;   //RXD映射P25  
  36   1        
  37   1        //波特率计算
  38   1        //波特率 = 1/16 * (T4时钟源频率 / 定时器4预分频比) / (65536 - 0xFF98)
  39   1        //       = 1/16 * ((16000000 / 1) / 104)
  40   1        //     = 9615.38(误差0.16%)
  41   1      
  42   1        //波特率9600
  43   1        //反推初值 = (65536 - ((T4时钟源频率 / 定时器4预分频比) * (1 / 16)) / 波特率)
  44   1        //       = (65536 - (16000000 * (1 / 16) / 9600))
  45   1        //       = (65536 - 104.167)
  46   1        //         = FF98
  47   1        // TH4 = 0xFF;
  48   1        // TL4 = 0x98;      //波特率9600
  49   1        TH4 = 0xFF;//9600  4M 波特率9600
  50   1        TL4 = 0x98; 
  51   1        T4CON = 0x06;   //T4工作模式：UART1波特率发生器
  52   1        SCON2 = 0x02;   //8位UART，波特率可变 方式一
C51 COMPILER V9.56.0.0   UART                                                              11/02/2020 19:34:56 PAGE 2   

  53   1        SCON = 0x10;    //允许串行接收
  54   1        IE |= 0x10;             //使能串口中断
  55   1        //#endif
  56   1      }
  57          
  58          
  59          //串口发送一个字符
  60           void hal_uart_putchar(char Char)
  61          {
  62   1          IE &=~ 0x10;        //失能UART1中断
  63   1        SBUF = Char;
  64   1        while(!(SCON & 0x02));
  65   1        SCON &=~ 0x02;        //清除发送中断标志位
  66   1        IE |= 0x10;         //UART1中断使能
  67   1        SCON |= 0x10;       //UART1接收使能
  68   1      }
  69          
  70          
  71          /* @function:串口发送一个字节
  72           * @param:需要发送的字节
  73           * @return:None
  74           */
  75          static void producte_com_send_one_bit(char Data)
  76          {
  77   1         hal_uart_putchar(Data);
  78   1      }
  79          /* @function:串口发送数组
  80           * @param:data:数组头指针
  81           *        len:数组长度
  82           * @return:None
  83           */
  84          static void producte_com_send_data(u8 *Data, u8 len)
  85          {
  86   1          u8 i;
  87   1          for (i = 0; i < len; i++)
  88   1          {
  89   2              producte_com_send_one_bit(Data[i]);
  90   2          }
  91   1      }
  92          
  93          /* @function:发送命令
  94           * @param:funcode:功能码
  95           *        data:数据
  96           * @return:None
  97           */
  98           void producte_send_cmd(u8 funcode, u8 Data)
  99          {
 100   1          struct producte_cmd_struct cmd_t;
 101   1          cmd_t.header = PRODUCTE_CMD_HEADER_VALUE;
 102   1          cmd_t.funcode = funcode;
 103   1          cmd_t.Data = Data;
 104   1          cmd_t.tail1 = PRODUCTE_CMD_TAIL1_VALUE;
 105   1          cmd_t.tail2 = PRODUCTE_CMD_TAIL2_VALUE;
 106   1          producte_com_send_data((u8 *)&cmd_t, sizeof(struct producte_cmd_struct));
 107   1      }
 108          
 109          
 110          //重写stdio 中的putchar函数  实现printf
 111          char putchar(char c)
 112          {
 113   1        hal_uart_putchar(c);
 114   1        return c;
C51 COMPILER V9.56.0.0   UART                                                              11/02/2020 19:34:56 PAGE 3   

 115   1      }
 116          
 117          
 118          void UART1_Rpt(void) interrupt UART1_VECTOR
 119          {
 120   1         u8 Data = 0;
 121   1        if(SCON & 0x01)           //判断接收中断标志位
 122   1        {
 123   2          Data = SBUF;        //转存8位串口接收数据  
 124   2        //  hal_uart_putchar( Data);
 125   2          SCON &=~ 0x01;                //清除接收中断标志位
 126   2          uart_receive_input(Data);
 127   2           /* receive Data */
 128   2      //        switch(usart_rx_flag)
 129   2      //        {
 130   2      //            case 0:
 131   2      //                if(Data == 0x55)
 132   2      //                {
 133   2      //                    usart_rx_buffer[0] = Data;
 134   2      //                    usart_rx_cnt++;
 135   2      //                    putchar( usart_rx_cnt);
 136   2      //                    usart_rx_flag = 1;
 137   2      //                   hal_uart_putchar( Data);
 138   2      //                   LED1 = !LED1;
 139   2      //                  
 140   2      //                }
 141   2      //                break;
 142   2      //            case 1:
 143   2      //      
 144   2      //          temper_val = Data;
 145   2      //           hal_uart_putchar( temper_val);
 146   2      //         usart_rx_flag = 2;
 147   2      //        
 148   2      //                break;
 149   2      //
 150   2      //        }
 151   2              
 152   2          
 153   2          }
 154   1        }                 
 155          
 156          
 157          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    216    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     33       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
