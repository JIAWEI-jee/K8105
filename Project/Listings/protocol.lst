C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE PROTOCOL
OBJECT MODULE PLACED IN .\Objects\protocol.obj
COMPILER INVOKED BY: C:\program_list\keil\C51\BIN\C51.EXE ..\hardware\TUYA\protocol.c LARGE OPTIMIZE(8,SPEED) BROWSE INC
                    -DIR(..\hardware\DELAY;..\hardware\ADC;..\hardware\Flash;..\hardware\Uart;..\hardware\Key;..\hardware\Pwm;..\hardware\WDT
                    -;..\hardware\Timer;..\hardware\LCDdisplay;..\hardware\PID;..\hardware\TUYA) DEBUG OBJECTEXTEND PRINT(.\Listings\protocol
                    -.lst) TABS(2) OBJECT(.\Objects\protocol.obj)

line level    source

   1          /**********************************Copyright (c)**********************************
   2          **                       ç‰ˆæƒæ‰€æœ‰ (C), 2015-2020, æ¶‚é¸¦ç§‘æŠ€
   3          **
   4          **                             http://www.tuya.com
   5          **
   6          *********************************************************************************/
   7          /**
   8           * @file    protocol.c
   9           * @author  æ¶‚é¸¦ç»¼åˆåè®®å¼€å‘ç»„
  10           * @version v2.5.5
  11           * @date    2020.6.1
  12           * @brief                
  13           *                       *******éå¸¸é‡è¦ï¼Œä¸€å®šè¦çœ‹å“¦ï¼ï¼ï¼********
  14           *          1. ç”¨æˆ·åœ¨æ­¤æ–‡ä»¶ä¸­å®ç°æ•°æ®ä¸‹å‘/ä¸ŠæŠ¥åŠŸèƒ½
  15           *          2. DPçš„ID/TYPEåŠæ•°æ®å¤„ç†å‡½æ•°éƒ½éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…å®šä¹‰å®ç°
  16           *          3. å½“å¼€å§‹æŸäº›å®å®šä¹‰åéœ€è¦ç”¨æˆ·å®ç°ä»£ç çš„å‡½æ•°å†…éƒ¨æœ‰#erræç¤º,å®Œæˆå‡½æ•
             -°åè¯·åˆ é™¤è¯¥#err
  17           */
  18          
  19          /******************************************************************************
  20                                          ç§»æ¤é¡»çŸ¥:
  21          1:MCUå¿…é¡»åœ¨whileä¸­ç›´æ¥è°ƒç”¨mcu_api.cå†…çš„wifi_uart_service()å‡½æ•°
  22          2:ç¨‹åºæ­£å¸¸åˆå§‹åŒ–å®Œæˆå,å»ºè®®ä¸è¿›è¡Œå…³ä¸²å£ä¸­æ–­,å¦‚å¿…é¡»å…³ä¸­æ–­,å…³ä¸­æ–­æ—¶é—´å¿…é¡»çŸ
             -­,å…³ä¸­æ–­ä¼šå¼•èµ·ä¸²å£æ•°æ®åŒ…ä¸¢å¤±
  23          3:è¯·å‹¿åœ¨ä¸­æ–­/å®šæ—¶å™¨ä¸­æ–­å†…è°ƒç”¨ä¸ŠæŠ¥å‡½æ•°
  24          ******************************************************************************/
  25          
  26          #include "wifi.h"
  27          
  28          #ifdef WEATHER_ENABLE
              /**
               * @var    weather_choose
               * @brief  å¤©æ°”æ•°æ®å‚æ•°é€‰æ‹©æ•°ç»„
               * @note   ç”¨æˆ·å¯ä»¥è‡ªå®šä¹‰éœ€è¦çš„å‚æ•°ï¼Œæ³¨é‡Šæˆ–è€…å–æ¶ˆæ³¨é‡Šå³å¯ï¼Œæ³¨æ„æ›´æ”¹
               */
              const char *weather_choose[WEATHER_CHOOSE_CNT] = {
                  "temp",
                  "humidity",
                  "condition",
                  "pm25",
                  /*"pressure",
                  "realFeel",
                  "uvi",
                  "tips",
                  "windDir",
                  "windLevel",
                  "windSpeed",
                  "sunRise",
                  "sunSet",
                  "aqi",
                  "so2 ",
                  "rank",
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 2   

                  "pm10",
                  "o3",
                  "no2",
                  "co",*/
              };
              #endif
  57          
  58          
  59          /******************************************************************************
  60                                        ç¬¬ä¸€æ­¥:åˆå§‹åŒ–
  61          1:åœ¨éœ€è¦ä½¿ç”¨åˆ°wifiç›¸å…³æ–‡ä»¶çš„æ–‡ä»¶ä¸­include "wifi.h"
  62          2:åœ¨MCUåˆå§‹åŒ–ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶ä¸­çš„wifi_protocol_init()å‡½æ•°
  63          3:å°†MCUä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°å¡«å…¥protocol.cæ–‡ä»¶ä¸­uart_transmit_outputå‡½æ•°å†…,å¹¶åˆ é™¤#error
  64          4:åœ¨MCUä¸²å£æ¥æ”¶å‡½æ•°ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„uart_receive_inputå‡½æ•°,å¹¶å°†æ¥æ”¶åˆ°çš„å­—èŠ‚ä
             -½œä¸ºå‚æ•°ä¼ å…¥
  65          5:å•ç‰‡æœºè¿›å…¥whileå¾ªç¯åè°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„wifi_uart_service()å‡½æ•°
  66          ******************************************************************************/
  67          
  68          /******************************************************************************
  69                                  1:dpæ•°æ®ç‚¹åºåˆ—ç±»å‹å¯¹ç…§è¡¨
  70                    **æ­¤ä¸ºè‡ªåŠ¨ç”Ÿæˆä»£ç ,å¦‚åœ¨å¼€å‘å¹³å°æœ‰ç›¸å…³ä¿®æ”¹è¯·é‡æ–°ä¸‹è½½MCU_SDK**         
  71          ******************************************************************************/
  72          const DOWNLOAD_CMD_S download_cmd[] =
  73          {
  74            {DPID_SWITCH, DP_TYPE_BOOL},
  75            {DPID_TEMP_SET, DP_TYPE_VALUE},
  76            {DPID_TEMP_CURRENT, DP_TYPE_VALUE},
  77            {DPID_LEVEL, DP_TYPE_ENUM},
  78            {DPID_COUNTDOWN_SET, DP_TYPE_ENUM},
  79            {DPID_COUNTDOWN_LEFT, DP_TYPE_VALUE},
  80            {DPID_PREHEAT, DP_TYPE_BOOL},
  81            {DPID_FAULT, DP_TYPE_BITMAP},
  82            {DPID_PREHEAT_1, DP_TYPE_BOOL},
  83          };
  84          
  85          
  86          
  87          /******************************************************************************
  88                                     2:ä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°
  89          è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°å†…,å¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥ä¸²å£å‘é€å‡½æ•°
  90          ******************************************************************************/
  91          
  92          /**
  93           * @brief  ä¸²å£å‘é€æ•°æ®
  94           * @param[in] {value} ä¸²å£è¦å‘é€çš„1å­—èŠ‚æ•°æ®
  95           * @return Null
  96           */
  97          void uart_transmit_output(unsigned char value)
  98          {
  99   1      //    #error "è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°,å¹¶åˆ é™¤è¯¥è¡Œ"
 100   1            hal_uart_putchar(value);
 101   1      /*
 102   1          //Example:
 103   1          extern void Uart_PutChar(unsigned char value);
 104   1          Uart_PutChar(value);                                  //ä¸²å£å‘é€å‡½æ•°
 105   1      */
 106   1      }
 107          
 108          /******************************************************************************
 109                                     ç¬¬äºŒæ­¥:å®ç°å…·ä½“ç”¨æˆ·å‡½æ•°
 110          1:APPä¸‹å‘æ•°æ®å¤„ç†
 111          2:æ•°æ®ä¸ŠæŠ¥å¤„ç†
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 3   

 112          ******************************************************************************/
 113          
 114          /******************************************************************************
 115                                      1:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 116          å½“å‰å‡½æ•°å¤„ç†å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥(åŒ…æ‹¬å¯ä¸‹å‘/å¯ä¸ŠæŠ¥å’Œåªä¸ŠæŠ¥)
 117            éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…æƒ…å†µå®ç°:
 118            1:éœ€è¦å®ç°å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 119            2:éœ€è¦å®ç°åªä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 120          æ­¤å‡½æ•°ä¸ºMCUå†…éƒ¨å¿…é¡»è°ƒç”¨
 121          ç”¨æˆ·ä¹Ÿå¯è°ƒç”¨æ­¤å‡½æ•°å®ç°å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥
 122          ******************************************************************************/
 123          
 124          //è‡ªåŠ¨åŒ–ç”Ÿæˆæ•°æ®ä¸ŠæŠ¥å‡½æ•°
 125          
 126          /**
 127           * @brief  ç³»ç»Ÿæ‰€æœ‰dpç‚¹ä¿¡æ¯ä¸Šä¼ ,å®ç°APPå’Œmucæ•°æ®åŒæ­¥
 128           * @param  Null
 129           * @return Null
 130           * @note   æ­¤å‡½æ•°SDKå†…éƒ¨éœ€è°ƒç”¨ï¼ŒMCUå¿…é¡»å®ç°è¯¥å‡½æ•°å†…æ•°æ®ä¸ŠæŠ¥åŠŸèƒ½ï¼ŒåŒ…æ‹¬åªä¸ŠæŠ¥å’
             -Œå¯ä¸ŠæŠ¥å¯ä¸‹å‘å‹æ•°æ®
 131           */
 132          void all_data_update(void)
 133          {
 134   1      //    #error "è¯·åœ¨æ­¤å¤„ç†å¯ä¸‹å‘å¯ä¸ŠæŠ¥æ•°æ®åŠåªä¸ŠæŠ¥æ•°æ®ç¤ºä¾‹,å¤„ç†å®Œæˆååˆ é™¤è¯¥è¡Œ"
 135   1         
 136   1          //æ­¤ä»£ç ä¸ºå¹³å°è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·æŒ‰ç…§å®é™…æ•°æ®ä¿®æ”¹æ¯ä¸ªå¯ä¸‹å‘å¯ä¸ŠæŠ¥å‡½æ•°å’Œåªä¸Šæ
             -Š¥å‡½æ•°
 137   1          mcu_dp_bool_update(DPID_SWITCH,get_device_state()); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 138   1          mcu_dp_value_update(DPID_TEMP_SET,25); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 139   1          mcu_dp_value_update(DPID_TEMP_CURRENT,25); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 140   1          mcu_dp_enum_update(DPID_LEVEL,flash_info.gap); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 141   1          mcu_dp_enum_update(DPID_COUNTDOWN_SET,0); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 142   1          mcu_dp_value_update(DPID_COUNTDOWN_LEFT,0); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 143   1          mcu_dp_bool_update(DPID_PREHEAT,0); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 144   1          mcu_dp_fault_update(DPID_FAULT,0); //æ•…éšœå‹æ•°æ®ä¸ŠæŠ¥;
 145   1          mcu_dp_bool_update(DPID_PREHEAT_1,0); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 146   1      }
 147          
 148          
 149          /******************************************************************************
 150                                          WARNING!!!    
 151                                      2:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 152          è‡ªåŠ¨åŒ–ä»£ç æ¨¡æ¿å‡½æ•°,å…·ä½“è¯·ç”¨æˆ·è‡ªè¡Œå®ç°æ•°æ®å¤„ç†
 153          ******************************************************************************/
 154          /*****************************************************************************
 155          å‡½æ•°åç§° : dp_download_switch_handle
 156          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCHçš„å¤„ç†å‡½æ•°
 157          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 158                  : length:æ•°æ®é•¿åº¦
 159          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 160          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 161          *****************************************************************************/
 162          static unsigned char dp_download_switch_handle(const unsigned char value[], unsigned short length)
 163          {
 164   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 165   1          unsigned char ret;
 166   1          //0:å…³/1:å¼€
 167   1          unsigned char switch_1;
 168   1          
 169   1          switch_1 = mcu_get_dp_download_bool(value,length);
 170   1          if(switch_1 == 0) {
 171   2          set_device_state ( OFF );
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 4   

 172   2              //å¼€å…³å…³
 173   2          }else {
 174   2              //å¼€å…³å¼€
 175   2              set_device_state ( ON );
 176   2          }
 177   1        
 178   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 179   1          ret = mcu_dp_bool_update(DPID_SWITCH,switch_1);
 180   1          if(ret == SUCCESS)
 181   1              return SUCCESS;
 182   1          else
 183   1              return ERROR;
 184   1      }
 185          /*****************************************************************************
 186          å‡½æ•°åç§° : dp_download_temp_set_handle
 187          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_SETçš„å¤„ç†å‡½æ•°
 188          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 189                  : length:æ•°æ®é•¿åº¦
 190          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 191          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 192          *****************************************************************************/
 193          static unsigned char dp_download_temp_set_handle(const unsigned char value[], unsigned short length)
 194          {
 195   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 196   1          unsigned char ret;
 197   1          unsigned long temp_set;
 198   1          
 199   1          temp_set = mcu_get_dp_download_value(value,length);
 200   1          /*
 201   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 202   1          
 203   1          */
 204   1          
 205   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 206   1          ret = mcu_dp_value_update(DPID_TEMP_SET,temp_set);
 207   1          if(ret == SUCCESS)
 208   1              return SUCCESS;
 209   1          else
 210   1              return ERROR;
 211   1      }
 212          /*****************************************************************************
 213          å‡½æ•°åç§° : dp_download_level_handle
 214          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_LEVELçš„å¤„ç†å‡½æ•°
 215          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 216                  : length:æ•°æ®é•¿åº¦
 217          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 218          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 219          *****************************************************************************/
 220          static unsigned char dp_download_level_handle(const unsigned char value[], unsigned short length)
 221          {
 222   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºENUM
 223   1          unsigned char ret;
 224   1          unsigned char level;
 225   1          
 226   1          level = mcu_get_dp_download_enum(value,length);
 227   1          switch(level) {
 228   2              case 0:
 229   2              break;
 230   2              
 231   2              case 1:
 232   2              break;
 233   2              
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 5   

 234   2              case 2:
 235   2              break;
 236   2              
 237   2              case 3:
 238   2              break;
 239   2              
 240   2              case 4:
 241   2              break;
 242   2              
 243   2              case 5:
 244   2              break;
 245   2              
 246   2              case 6:
 247   2              break;
 248   2              
 249   2              case 7:
 250   2              break;
 251   2              
 252   2              case 8:
 253   2              break;
 254   2              
 255   2              default:
 256   2          
 257   2              break;
 258   2          }
 259   1          
 260   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 261   1          ret = mcu_dp_enum_update(DPID_LEVEL, level);
 262   1          if(ret == SUCCESS)
 263   1              return SUCCESS;
 264   1          else
 265   1              return ERROR;
 266   1      }
 267          /*****************************************************************************
 268          å‡½æ•°åç§° : dp_download_countdown_set_handle
 269          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_COUNTDOWN_SETçš„å¤„ç†å‡½æ•°
 270          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 271                  : length:æ•°æ®é•¿åº¦
 272          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 273          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 274          *****************************************************************************/
 275          static unsigned char dp_download_countdown_set_handle(const unsigned char value[], unsigned short length)
 276          {
 277   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºENUM
 278   1          unsigned char ret;
 279   1          unsigned char countdown_set;
 280   1          
 281   1          countdown_set = mcu_get_dp_download_enum(value,length);
 282   1          switch(countdown_set) {
 283   2              case 0:
 284   2              break;
 285   2              
 286   2              case 1:
 287   2              break;
 288   2              
 289   2              case 2:
 290   2              break;
 291   2              
 292   2              case 3:
 293   2              break;
 294   2              
 295   2              case 4:
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 6   

 296   2              break;
 297   2              
 298   2              case 5:
 299   2              break;
 300   2              
 301   2              default:
 302   2          
 303   2              break;
 304   2          }
 305   1          
 306   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 307   1          ret = mcu_dp_enum_update(DPID_COUNTDOWN_SET, countdown_set);
 308   1          if(ret == SUCCESS)
 309   1              return SUCCESS;
 310   1          else
 311   1              return ERROR;
 312   1      }
 313          /*****************************************************************************
 314          å‡½æ•°åç§° : dp_download_preheat_handle
 315          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_PREHEATçš„å¤„ç†å‡½æ•°
 316          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 317                  : length:æ•°æ®é•¿åº¦
 318          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 319          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 320          *****************************************************************************/
 321          static unsigned char dp_download_preheat_handle(const unsigned char value[], unsigned short length)
 322          {
 323   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 324   1          unsigned char ret;
 325   1          //0:å…³/1:å¼€
 326   1          unsigned char preheat;
 327   1          
 328   1          preheat = mcu_get_dp_download_bool(value,length);
 329   1          if(preheat == 0) {
 330   2              //å¼€å…³å…³
 331   2          }else {
 332   2              //å¼€å…³å¼€
 333   2          }
 334   1        
 335   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 336   1          ret = mcu_dp_bool_update(DPID_PREHEAT,preheat);
 337   1          if(ret == SUCCESS)
 338   1              return SUCCESS;
 339   1          else
 340   1              return ERROR;
 341   1      }
 342          /*****************************************************************************
 343          å‡½æ•°åç§° : dp_download_preheat_1_handle
 344          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_PREHEAT_1çš„å¤„ç†å‡½æ•°
 345          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 346                  : length:æ•°æ®é•¿åº¦
 347          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 348          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 349          *****************************************************************************/
 350          static unsigned char dp_download_preheat_1_handle(const unsigned char value[], unsigned short length)
 351          {
 352   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 353   1          unsigned char ret;
 354   1          //0:å…³/1:å¼€
 355   1          unsigned char preheat_1;
 356   1          
 357   1          preheat_1 = mcu_get_dp_download_bool(value,length);
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 7   

 358   1          if(preheat_1 == 0) {
 359   2              //å¼€å…³å…³
 360   2          }else {
 361   2              //å¼€å…³å¼€
 362   2          }
 363   1        
 364   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 365   1          ret = mcu_dp_bool_update(DPID_PREHEAT_1,preheat_1);
 366   1          if(ret == SUCCESS)
 367   1              return SUCCESS;
 368   1          else
 369   1              return ERROR;
 370   1      }
 371          
 372          
 373          
 374          
 375          /******************************************************************************
 376                                          WARNING!!!                     
 377          æ­¤éƒ¨åˆ†å‡½æ•°ç”¨æˆ·è¯·å‹¿ä¿®æ”¹!!
 378          ******************************************************************************/
 379          
 380          /**
 381           * @brief  dpä¸‹å‘å¤„ç†å‡½æ•°
 382           * @param[in] {dpid} dpid åºå·
 383           * @param[in] {value} dpæ•°æ®ç¼“å†²åŒºåœ°å€
 384           * @param[in] {length} dpæ•°æ®é•¿åº¦
 385           * @return dpå¤„ç†ç»“æœ
 386           * -           0(ERROR): å¤±è´¥
 387           * -           1(SUCCESS): æˆåŠŸ
 388           * @note   è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 389           */
 390          unsigned char dp_download_handle(unsigned char dpid,const unsigned char value[], unsigned short length)
 391          {
 392   1          /*********************************
 393   1          å½“å‰å‡½æ•°å¤„ç†å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®è°ƒç”¨                    
 394   1          å…·ä½“å‡½æ•°å†…éœ€è¦å®ç°ä¸‹å‘æ•°æ®å¤„ç†
 395   1          å®Œæˆç”¨éœ€è¦å°†å¤„ç†ç»“æœåé¦ˆè‡³APPç«¯,å¦åˆ™APPä¼šè®¤ä¸ºä¸‹å‘å¤±è´¥
 396   1          ***********************************/
 397   1          unsigned char ret;
 398   1          switch(dpid) {
 399   2              case DPID_SWITCH:
 400   2                  //å¼€å…³å¤„ç†å‡½æ•°
 401   2                  ret = dp_download_switch_handle(value,length);
 402   2              break;
 403   2              case DPID_TEMP_SET:
 404   2                  //æ¸©åº¦è®¾ç½®å¤„ç†å‡½æ•°
 405   2                  ret = dp_download_temp_set_handle(value,length);
 406   2              break;
 407   2              case DPID_LEVEL:
 408   2                  //æ¡£ä½å¤„ç†å‡½æ•°
 409   2                  ret = dp_download_level_handle(value,length);
 410   2              break;
 411   2              case DPID_COUNTDOWN_SET:
 412   2                  //å€’è®¡æ—¶å¤„ç†å‡½æ•°
 413   2                  ret = dp_download_countdown_set_handle(value,length);
 414   2              break;
 415   2              case DPID_PREHEAT:
 416   2                  //æ˜¯å¦é¢„çƒ­å¤„ç†å‡½æ•°
 417   2                  ret = dp_download_preheat_handle(value,length);
 418   2              break;
 419   2              case DPID_PREHEAT_1:
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 8   

 420   2                  //é¢„çƒ­1å¤„ç†å‡½æ•°
 421   2                  ret = dp_download_preheat_1_handle(value,length);
 422   2              break;
 423   2      
 424   2              
 425   2              default:
 426   2              break;
 427   2          }
 428   1          return ret;
 429   1      }
 430          
 431          /**
 432           * @brief  è·å–æ‰€æœ‰dpå‘½ä»¤æ€»å’Œ
 433           * @param[in] Null
 434           * @return ä¸‹å‘å‘½ä»¤æ€»å’Œ
 435           * @note   è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 436           */
 437          unsigned char get_download_cmd_total(void)
 438          {
 439   1          return(sizeof(download_cmd) / sizeof(download_cmd[0]));
 440   1      }
 441          
 442          
 443          /******************************************************************************
 444                                          WARNING!!!                     
 445          æ­¤ä»£ç ä¸ºSDKå†…éƒ¨è°ƒç”¨,è¯·æŒ‰ç…§å®é™…dpæ•°æ®å®ç°å‡½æ•°å†…éƒ¨æ•°æ®
 446          ******************************************************************************/
 447          
 448          #ifdef SUPPORT_MCU_FIRM_UPDATE
              /**
               * @brief  å‡çº§åŒ…å¤§å°é€‰æ‹©
               * @param[in] {package_sz} å‡çº§åŒ…å¤§å°
               * @ref           0x00: 256byte (é»˜è®¤)
               * @ref           0x01: 512byte
               * @ref           0x02: 1024byte
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void upgrade_package_choose(unsigned char package_sz)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è¯·è‡ªè¡Œå®ç°å‡çº§åŒ…å¤§å°é€‰æ‹©ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned short send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, package_sz);
                  wifi_uart_write_frame(UPDATE_START_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  MCUè¿›å…¥å›ºä»¶å‡çº§æ¨¡å¼
               * @param[in] {value} å›ºä»¶ç¼“å†²åŒº
               * @param[in] {position} å½“å‰æ•°æ®åŒ…åœ¨äºå›ºä»¶ä½ç½®
               * @param[in] {length} å½“å‰å›ºä»¶åŒ…é•¿åº¦(å›ºä»¶åŒ…é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºå›ºä»¶åŒ…å‘é€å®Œæˆ)
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              unsigned char mcu_firm_update_handle(const unsigned char value[],unsigned long position,unsigned short len
             -gth)
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆMCUå›ºä»¶å‡çº§ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(length == 0) {
                      //å›ºä»¶æ•°æ®å‘é€å®Œæˆ
                    
                  }else {
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 9   

                      //å›ºä»¶æ•°æ®å¤„ç†
                    
                  }
                  
                  return SUCCESS;
              }
              #endif
 488          
 489          #ifdef SUPPORT_GREEN_TIME
              /**
               * @brief  è·å–åˆ°çš„æ ¼æ—æ—¶é—´
               * @param[in] {time} è·å–åˆ°çš„æ ¼æ—æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_get_greentime(unsigned char time[])
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆç›¸å…³ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  time[0] ä¸ºæ˜¯å¦è·å–æ—¶é—´æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1è¡¨ç¤ºæˆåŠŸ
                  time[1] ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º 2000 å¹´
                  time[2] ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                  time[3] ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                  time[4] ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                  time[5] ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  time[6] ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  */
                  if(time[0] == 1) {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„æ ¼æ—æ•°æ®
                      
                  }else {
                      //è·å–æ ¼æ—æ—¶é—´å‡ºé”™,æœ‰å¯èƒ½æ˜¯å½“å‰wifiæ¨¡å—æœªè”ç½‘
                  }
              }
              #endif
 516          
 517          #ifdef SUPPORT_MCU_RTC_CHECK
              /**
               * @brief  MCUæ ¡å¯¹æœ¬åœ°RTCæ—¶é’Ÿ
               * @param[in] {time} è·å–åˆ°çš„æ ¼æ—æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_write_rtctime(unsigned char time[])
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆRTCæ—¶é’Ÿå†™å…¥ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  Time[0] ä¸ºæ˜¯å¦è·å–æ—¶é—´æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1è¡¨ç¤ºæˆåŠŸ
                  Time[1] ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º 2000 å¹´
                  Time[2] ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                  Time[3] ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                  Time[4] ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                  Time[5] ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  Time[6] ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  Time[7] ä¸ºæ˜ŸæœŸï¼Œä» 1 å¼€å§‹åˆ° 7 ç»“æŸï¼Œ1ä»£è¡¨æ˜ŸæœŸä¸€
                 */
                  if(time[0] == 1) {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„æœ¬åœ°æ—¶é’Ÿæ•°æ®
                   
                  }else {
                      //è·å–æœ¬åœ°æ—¶é’Ÿæ•°æ®å‡ºé”™,æœ‰å¯èƒ½æ˜¯å½“å‰wifiæ¨¡å—æœªè”ç½‘
                  }
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 10  

              }
              #endif
 545          
 546          #ifdef WIFI_TEST_ENABLE
 547          /**
 548           * @brief  wifiåŠŸèƒ½æµ‹è¯•åé¦ˆ
 549           * @param[in] {result} wifiåŠŸèƒ½æµ‹è¯•ç»“æœ
 550           * @ref       0: å¤±è´¥
 551           * @ref       1: æˆåŠŸ
 552           * @param[in] {rssi} æµ‹è¯•æˆåŠŸè¡¨ç¤ºwifiä¿¡å·å¼ºåº¦/æµ‹è¯•å¤±è´¥è¡¨ç¤ºé”™è¯¯ç±»å‹
 553           * @return Null
 554           * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
 555           */
 556          void wifi_test_result(unsigned char result,unsigned char rssi)
 557          {
 558   1      //    #error "è¯·è‡ªè¡Œå®ç°wifiåŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
 559   1          if(result == 0) {
 560   2              //æµ‹è¯•å¤±è´¥
 561   2              if(rssi == 0x00) {
 562   3                  //æœªæ‰«æåˆ°åç§°ä¸ºtuya_mdev_testè·¯ç”±å™¨,è¯·æ£€æŸ¥
 563   3              }else if(rssi == 0x01) {
 564   3                  //æ¨¡å—æœªæˆæƒ
 565   3              }
 566   2          }else {
 567   2              //æµ‹è¯•æˆåŠŸ
 568   2              //rssiä¸ºä¿¡å·å¼ºåº¦(0-100, 0ä¿¡å·æœ€å·®ï¼Œ100ä¿¡å·æœ€å¼º)
 569   2          }
 570   1      }
 571          #endif
 572          
 573          #ifdef WEATHER_ENABLE
              /**
              * @brief  mcuæ‰“å¼€å¤©æ°”æœåŠ¡
               * @param  Null
               * @return Null
               */
              void mcu_open_weather(void)
              {
                  int i = 0;
                  char buffer[13] = {0};
                  unsigned char weather_len = 0;
                  unsigned short send_len = 0;
                  
                  weather_len = sizeof(weather_choose) / sizeof(weather_choose[0]);
                    
                  for(i=0;i<weather_len;i++) {
                      buffer[0] = sprintf(buffer+1,"w.%s",weather_choose[i]);
                      send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  }
                  
                  #error "è¯·æ ¹æ®æç¤ºï¼Œè‡ªè¡Œå®Œå–„æ‰“å¼€å¤©æ°”æœåŠ¡ä»£ç ï¼Œå®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  /*
                  //å½“è·å–çš„å‚æ•°æœ‰å’Œæ—¶é—´æœ‰å…³çš„å‚æ•°æ—¶(å¦‚:æ—¥å‡ºæ—¥è½)ï¼Œéœ€è¦æ­é…t.unixæˆ–è€…t.local
             -ä½¿ç”¨ï¼Œéœ€è¦è·å–çš„å‚æ•°æ•°æ®æ˜¯æŒ‰ç…§æ ¼æ—æ—¶é—´è¿˜æ˜¯æœ¬åœ°æ—¶é—´
                  buffer[0] = sprintf(buffer+1,"t.unix"); //æ ¼æ—æ—¶é—´   æˆ–ä½¿ç”¨  buffer[0] = sprintf(buffer+1,"t.lo
             -cal"); //æœ¬åœ°æ—¶é—´
                  send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  */
                  
                  buffer[0] = sprintf(buffer+1,"w.date.%d",WEATHER_FORECAST_DAYS_NUM);
                  send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 11  

                  wifi_uart_write_frame(WEATHER_OPEN_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  æ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›ç”¨æˆ·è‡ªå¤„ç†å‡½æ•°
               * @param[in] {res} æ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›ç»“æœ
               * @ref       0: å¤±è´¥
               * @ref       1: æˆåŠŸ
               * @param[in] {err} é”™è¯¯ç 
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void weather_open_return_handle(unsigned char res, unsigned char err)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆæ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›æ•°æ®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char err_num = 0;
                  
                  if(res == 1) {
                      //æ‰“å¼€å¤©æ°”è¿”å›æˆåŠŸ
                  }else if(res == 0) {
                      //æ‰“å¼€å¤©æ°”è¿”å›å¤±è´¥
                      //è·å–é”™è¯¯ç 
                      err_num = err; 
                  }
              }
              
              /**
               * @brief  å¤©æ°”æ•°æ®ç”¨æˆ·è‡ªå¤„ç†å‡½æ•°
               * @param[in] {name} å‚æ•°å
               * @param[in] {type} å‚æ•°ç±»å‹
               * @ref       0: int å‹
               * @ref       1: string å‹
               * @param[in] {data} å‚æ•°å€¼çš„åœ°å€
               * @param[in] {day} å“ªä¸€å¤©çš„å¤©æ°”  0:è¡¨ç¤ºå½“å¤© å–å€¼èŒƒå›´: 0~6
               * @ref       0: ä»Šå¤©
               * @ref       1: æ˜å¤©
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void weather_data_user_handle(char *name, unsigned char type, const unsigned char *data, char day)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„å¤©æ°”æ•°æ®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  int value_int;
                  char value_string[50];//ç”±äºæœ‰çš„å‚æ•°å†…å®¹è¾ƒå¤šï¼Œè¿™é‡Œé»˜è®¤ä¸º50ã€‚æ‚¨å¯ä»¥æ ¹æ®å®šä¹‰çš„å
             -‚æ•°ï¼Œå¯ä»¥é€‚å½“å‡å°‘è¯¥å€¼
                  
                  my_memset(value_string, '\0', 50);
                  
                  //é¦–å…ˆè·å–æ•°æ®ç±»å‹
                  if(type == 0) { //å‚æ•°æ˜¯INTå‹
                      value_int = data[0] << 24 | data[1] << 16 | data[2] << 8 | data[3];
                  }else if(type == 1) {
                      my_strcpy(value_string, data);
                  }
                  
                  //æ³¨æ„è¦æ ¹æ®æ‰€é€‰å‚æ•°ç±»å‹æ¥è·å¾—å‚æ•°å€¼ï¼ï¼ï¼
                  if(my_strcmp(name, "temp") == 0) {
                      printf("day:%d temp value is:%d\r\n", day, value_int);          //int å‹
                  }else if(my_strcmp(name, "humidity") == 0) {
                      printf("day:%d humidity value is:%d\r\n", day, value_int);      //int å‹
                  }else if(my_strcmp(name, "pm25") == 0) {
                      printf("day:%d pm25 value is:%d\r\n", day, value_int);          //int å‹
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 12  

                  }else if(my_strcmp(name, "condition") == 0) {
                      printf("day:%d condition value is:%s\r\n", day, value_string);  //string å‹
                  }
              }
              #endif
 669          
 670          #ifdef MCU_DP_UPLOAD_SYN
              /**
               * @brief  çŠ¶æ€åŒæ­¥ä¸ŠæŠ¥ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0: å¤±è´¥
               * @ref       1: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_upload_syn_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆçŠ¶æ€åŒæ­¥ä¸ŠæŠ¥ç»“æœä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                    
                  if(result == 0) {
                      //åŒæ­¥ä¸ŠæŠ¥å‡ºé”™
                  }else {
                      //åŒæ­¥ä¸ŠæŠ¥æˆåŠŸ
                  }
              }
              #endif
 690          
 691          #ifdef GET_WIFI_STATUS_ENABLE
              /**
               * @brief  è·å– WIFI çŠ¶æ€ç»“æœ
               * @param[in] {result} æŒ‡ç¤º WIFI å·¥ä½œçŠ¶æ€
               * @ref       0x00: wifiçŠ¶æ€ 1 smartconfig é…ç½®çŠ¶æ€
               * @ref       0x01: wifiçŠ¶æ€ 2 AP é…ç½®çŠ¶æ€
               * @ref       0x02: wifiçŠ¶æ€ 3 WIFI å·²é…ç½®ä½†æœªè¿ä¸Šè·¯ç”±å™¨
               * @ref       0x03: wifiçŠ¶æ€ 4 WIFI å·²é…ç½®ä¸”è¿ä¸Šè·¯ç”±å™¨
               * @ref       0x04: wifiçŠ¶æ€ 5 å·²è¿ä¸Šè·¯ç”±å™¨ä¸”è¿æ¥åˆ°äº‘ç«¯
               * @ref       0x05: wifiçŠ¶æ€ 6 WIFI è®¾å¤‡å¤„äºä½åŠŸè€—æ¨¡å¼
               * @ref       0x06: wifiçŠ¶æ€ 7 WIFI è®¾å¤‡å¤„äºsmartconfig&APé…ç½®çŠ¶æ€
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_wifi_status(unsigned char result)
              {
                #error "è¯·è‡ªè¡Œå®Œæˆè·å– WIFI çŠ¶æ€ç»“æœä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
               
                  switch(result) {
                      case 0:
                          //wifiå·¥ä½œçŠ¶æ€1
                      break;
                  
                      case 1:
                          //wifiå·¥ä½œçŠ¶æ€2
                      break;
                      
                      case 2:
                          //wifiå·¥ä½œçŠ¶æ€3
                      break;
                      
                      case 3:
                          //wifiå·¥ä½œçŠ¶æ€4
                      break;
                      
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 13  

                      case 4:
                          //wifiå·¥ä½œçŠ¶æ€5
                      break;
                      
                      case 5:
                          //wifiå·¥ä½œçŠ¶æ€6
                      break;
                    
                      case 6:
                          //wifiå·¥ä½œçŠ¶æ€7
                      break;
                      
                      default:break;
                  }
              }
              #endif
 742          
 743          #ifdef WIFI_STREAM_ENABLE
              /**
               * @brief  æµæœåŠ¡å‘é€ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0x00: æˆåŠŸ
               * @ref       0x01: æµæœåŠ¡åŠŸèƒ½æœªå¼€å¯
               * @ref       0x02: æµæœåŠ¡å™¨æœªè¿æ¥æˆåŠŸ
               * @ref       0x03: æ•°æ®æ¨é€è¶…æ—¶
               * @ref       0x04: ä¼ è¾“çš„æ•°æ®é•¿åº¦é”™è¯¯
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void stream_trans_send_result(unsigned char result)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„æµæœåŠ¡å‘é€ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥
             -è¡Œ"
                  switch(result) {
                      case 0x00:
                          //æˆåŠŸ
                      break;
                      
                      case 0x01:
                          //æµæœåŠ¡åŠŸèƒ½æœªå¼€å¯
                      break;
                      
                      case 0x02:
                          //æµæœåŠ¡å™¨æœªè¿æ¥æˆåŠŸ
                      break;
                      
                      case 0x03:
                          //æ•°æ®æ¨é€è¶…æ—¶
                      break;
                      
                      case 0x04:
                          //ä¼ è¾“çš„æ•°æ®é•¿åº¦é”™è¯¯
                      break;
                      
                      default:break;
                  }
              }
              
              /**
               * @brief  å¤šåœ°å›¾æµæœåŠ¡å‘é€ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0x00: æˆåŠŸ
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 14  

               * @ref       0x01: å¤±è´¥
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void maps_stream_trans_send_result(unsigned char result)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„å¤šåœ°å›¾æµæœåŠ¡å‘é€ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·
             -åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0x00:
                          //æˆåŠŸ
                      break;
                      
                      case 0x01:
                          //å¤±è´¥
                      break;
                      
                      default:break;
                  }
              }
              #endif
 807          
 808          #ifdef WIFI_CONNECT_TEST_ENABLE
              /**
               * @brief  è·¯ç”±ä¿¡æ¯æ¥æ”¶ç»“æœé€šçŸ¥
               * @param[in] {result} æ¨¡å—æ˜¯å¦æˆåŠŸæ¥æ”¶åˆ°æ­£ç¡®çš„è·¯ç”±ä¿¡æ¯
               * @ref       0x00: å¤±è´¥
               * @ref       0x01: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void wifi_connect_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°wifiåŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0) {
                      //è·¯ç”±ä¿¡æ¯æ¥æ”¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘å‡ºçš„è·¯ç”±ä¿¡æ¯åŒ…æ˜¯å¦æ˜¯å®Œæ•´çš„JSONæ•°æ®åŒ…
                  }else {
                      //è·¯ç”±ä¿¡æ¯æ¥æ”¶æˆåŠŸï¼Œäº§æµ‹ç»“æœè¯·æ³¨æ„WIFI_STATE_CMDæŒ‡ä»¤çš„wifiå·¥ä½œçŠ¶æ€
                  }
              }
              #endif
 827          
 828          #ifdef GET_MODULE_MAC_ENABLE
              /**
               * @brief  è·å–æ¨¡å—macç»“æœ
               * @param[in] {mac} æ¨¡å— MAC æ•°æ®
               * @ref       mac[0]: ä¸ºæ˜¯å¦è·å–macæˆåŠŸæ ‡å¿—ï¼Œ0x00 è¡¨ç¤ºæˆåŠŸï¼Œ0x01 è¡¨ç¤ºå¤±è´¥
               * @ref       mac[1]~mac[6]: å½“è·å– MACåœ°å€æ ‡å¿—ä½å¦‚æœmac[0]ä¸ºæˆåŠŸï¼Œåˆ™è¡¨ç¤ºæ¨¡å—æœ‰æ•ˆçš„M
             -ACåœ°å€
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_get_mac(unsigned char mac[])
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆmacè·å–ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  mac[0]ä¸ºæ˜¯å¦è·å–macæˆåŠŸæ ‡å¿—ï¼Œ0x00 è¡¨ç¤ºæˆåŠŸï¼Œä¸º0x01è¡¨ç¤ºå¤±è´¥
                  mac[1]~mac[6]:å½“è·å– MACåœ°å€æ ‡å¿—ä½å¦‚æœmac[0]ä¸ºæˆåŠŸï¼Œåˆ™è¡¨ç¤ºæ¨¡å—æœ‰æ•ˆçš„MACåœ°å€
                 */
                 
                  if(mac[0] == 1) {
                      //è·å–macå‡ºé”™
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 15  

                  }else {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„macåœ°å€
                  }
              }
              #endif
 852          
 853          #ifdef GET_IR_STATUS_ENABLE
              /**
               * @brief  è·å–çº¢å¤–çŠ¶æ€ç»“æœ
               * @param[in] {result} æŒ‡ç¤ºçº¢å¤–çŠ¶æ€
               * @ref       0x00: çº¢å¤–çŠ¶æ€ 1 æ­£åœ¨å‘é€çº¢å¤–ç 
               * @ref       0x01: çº¢å¤–çŠ¶æ€ 2 å‘é€çº¢å¤–ç ç»“æŸ
               * @ref       0x02: çº¢å¤–çŠ¶æ€ 3 çº¢å¤–å­¦ä¹ å¼€å§‹
               * @ref       0x03: çº¢å¤–çŠ¶æ€ 4 çº¢å¤–å­¦ä¹ ç»“æŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_ir_status(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆçº¢å¤–çŠ¶æ€ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0:
                          //çº¢å¤–çŠ¶æ€ 1
                      break;
                    
                      case 1:
                          //çº¢å¤–çŠ¶æ€ 2
                      break;
                        
                      case 2:
                          //çº¢å¤–çŠ¶æ€ 3
                      break;
                        
                      case 3:
                          //çº¢å¤–çŠ¶æ€ 4
                      break;
                        
                      default:break;
                  }
                  
                  wifi_uart_write_frame(GET_IR_STATUS_CMD, MCU_TX_VER, 0);
              }
              #endif
 890          
 891          #ifdef IR_TX_RX_TEST_ENABLE
              /**
               * @brief  çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹ç»“æœé€šçŸ¥
               * @param[in] {result} æ¨¡å—æ˜¯å¦æˆåŠŸæ¥æ”¶åˆ°æ­£ç¡®çš„ä¿¡æ¯
               * @ref       0x00: å¤±è´¥
               * @ref       0x01: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void ir_tx_rx_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹åŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡
             -Œ"
                  if(result == 0) {
                      //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹æˆåŠŸ
                  }else {
                      //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘å‡ºçš„æ•°æ®åŒ…
                  }
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 16  

              }
              #endif
 910          
 911          #ifdef FILE_DOWNLOAD_ENABLE
              /**
               * @brief  æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°é€‰æ‹©
               * @param[in] {package_sz} æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°
               * @ref       0x00: 256 byte (é»˜è®¤)
               * @ref       0x01: 512 byte
               * @ref       0x02: 1024 byte
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void file_download_package_choose(unsigned char package_sz)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è¯·è‡ªè¡Œå®ç°æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°é€‰æ‹©ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned short send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, package_sz);
                  wifi_uart_write_frame(FILE_DOWNLOAD_START_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  æ–‡ä»¶åŒ…ä¸‹è½½æ¨¡å¼
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {position} å½“å‰æ•°æ®åŒ…åœ¨äºæ–‡ä»¶ä½ç½®
               * @param[in] {length} å½“å‰æ–‡ä»¶åŒ…é•¿åº¦(é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºæ–‡ä»¶åŒ…å‘é€å®Œæˆ)
               * @return æ•°æ®å¤„ç†ç»“æœ
               * -           0(ERROR): å¤±è´¥
               * -           1(SUCCESS): æˆåŠŸ
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              unsigned char file_download_handle(const unsigned char value[],unsigned long position,unsigned short lengt
             -h)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆæ–‡ä»¶åŒ…ä¸‹è½½ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(length == 0) {
                      //æ–‡ä»¶åŒ…æ•°æ®å‘é€å®Œæˆ
                      
                  }else {
                      //æ–‡ä»¶åŒ…æ•°æ®å¤„ç†
                    
                  }
                  
                  return SUCCESS;
              }
              #endif
 953          
 954          #ifdef MODULE_EXPANDING_SERVICE_ENABLE
              /**
               * @brief  æ‰“å¼€æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥ç»“æœ
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void open_module_time_serve_result(const unsigned char value[], unsigned short length)
              {
                  #error "è¯·è‡ªè¡Œå®ç°æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥ç»“æœä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char sub_cmd = value[0];
                  
                  switch(sub_cmd) {
                      case 0x01: { //å­å‘½ä»¤  æ‰“å¼€æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 17  

                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æœåŠ¡å¼€å¯æˆåŠŸ
                          }else {
                              //æœåŠ¡å¼€å¯å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x02: {  //å­å‘½ä»¤  æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥
                          if(0x09 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          unsigned char time_type = value[1]; //0x00:æ ¼æ—æ—¶é—´  0x01:æœ¬åœ°æ—¶é—´
                          unsigned char time_data[7];
                          
                          my_memcpy(time_data, value + 2, length - 2);
                          /*
                          Data[0]ä¸ºå¹´ä»½, 0x00è¡¨ç¤º2000å¹´
                          Data[1]ä¸ºæœˆä»½ï¼Œä»1å¼€å§‹åˆ°12ç»“æŸ
                          Data[2]ä¸ºæ—¥æœŸï¼Œä»1å¼€å§‹åˆ°31ç»“æŸ
                          Data[3]ä¸ºæ—¶é’Ÿï¼Œä»0å¼€å§‹åˆ°23ç»“æŸ
                          Data[4]ä¸ºåˆ†é’Ÿï¼Œä»0å¼€å§‹åˆ°59ç»“æŸ
                          Data[5]ä¸ºç§’é’Ÿï¼Œä»0å¼€å§‹åˆ°15ç»“æŸ
                          Data[6]ä¸ºæ˜ŸæœŸï¼Œä»1å¼€å§‹åˆ°7ç»“æŸï¼Œ1ä»£è¡¨æ˜ŸæœŸä¸€
                          */
                          
                          //åœ¨æ­¤å¤„æ·»åŠ æ—¶é—´æ•°æ®å¤„ç†ä»£ç ï¼Œtime_typeä¸ºæ—¶é—´ç±»å‹
                          
                          unsigned short send_len = 0;
                          send_len = set_wifi_uart_byte(send_len,sub_cmd);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
                      
                      case 0x03: {  //å­å‘½ä»¤  ä¸»åŠ¨è¯·æ±‚å¤©æ°”æœåŠ¡æ•°æ®
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x04: {  //å­å‘½ä»¤  æ‰“å¼€æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 18  

                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x05: {  //å­å‘½ä»¤  æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          switch(value[1]) {
                              case 0x00:
                                  //æ¨¡å—æœ¬åœ°é‡ç½®
                                  
                              break;
                              case 0x01:
                                  //APPè¿œç¨‹é‡ç½®
                                  
                              break;
                              case 0x02:
                                  //APPæ¢å¤å‡ºå‚é‡ç½®
                                  
                              break;
                              default:break;
                          }
                          
                          unsigned short send_len = 0;
                          send_len = set_wifi_uart_byte(send_len, sub_cmd);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
                      
                      default:break;
                  }
              }
              #endif
1070          
1071          #ifdef BLE_RELATED_FUNCTION_ENABLE
              /**
               * @brief  è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ç»“æœ
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void BLE_test_result(const unsigned char value[], unsigned short length)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ç»“æœä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char sub_cmd = value[0];
                  
                  if(0x03 != length) {
                      //æ•°æ®é•¿åº¦é”™è¯¯
                      return;
                  }
                  
                  if(0x01 != sub_cmd) {
                      //å­å‘½ä»¤é”™è¯¯
                      return;
                  }
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 19  

                  
                  unsigned char result = value[1];
                  unsigned char rssi = value[2];
                      
                  if(result == 0) {
                      //æµ‹è¯•å¤±è´¥
                      if(rssi == 0x00) {
                          //æœªæ‰«æåˆ°åç§°ä¸º ty_mdevè“ç‰™ä¿¡æ ‡,è¯·æ£€æŸ¥
                      }else if(rssi == 0x01) {
                          //æ¨¡å—æœªæˆæƒ
                      }
                  }else if(result == 0x01) {
                      //æµ‹è¯•æˆåŠŸ
                      //rssiä¸ºä¿¡å·å¼ºåº¦(0-100, 0ä¿¡å·æœ€å·®ï¼Œ100ä¿¡å·æœ€å¼º)
                  }
              }
              #endif
1110          
1111          #ifdef VOICE_MODULE_PROTOCOL_ENABLE
              /**
               * @brief  è·å–è¯­éŸ³çŠ¶æ€ç ç»“æœ
               * @param[in] {result} è¯­éŸ³çŠ¶æ€ç 
               * @ref       0x00: ç©ºé—²
               * @ref       0x01: micé™éŸ³çŠ¶æ€
               * @ref       0x02: å”¤é†’
               * @ref       0x03: æ­£åœ¨å½•éŸ³
               * @ref       0x04: æ­£åœ¨è¯†åˆ«
               * @ref       0x05: è¯†åˆ«æˆåŠŸ
               * @ref       0x06: è¯†åˆ«å¤±è´¥
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_voice_state_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è·å–è¯­éŸ³çŠ¶æ€ç ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0:
                          //ç©ºé—²
                      break;
                  
                      case 1:
                          //micé™éŸ³çŠ¶æ€
                      break;
                      
                      case 2:
                          //å”¤é†’
                      break;
                      
                      case 3:
                          //æ­£åœ¨å½•éŸ³
                      break;
                      
                      case 4:
                          //æ­£åœ¨è¯†åˆ«
                      break;
                  
                      case 5:
                          //è¯†åˆ«æˆåŠŸ
                      break;
                      
                      case 6:
                          //è¯†åˆ«å¤±è´¥
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 20  

                      break;
                      
                    default:break;
                  }
              }
              
              /**
               * @brief  MICé™éŸ³è®¾ç½®ç»“æœ
               * @param[in] {result} è¯­éŸ³çŠ¶æ€ç 
               * @ref       0x00: mic å¼€å¯
               * @ref       0x01: mic é™éŸ³
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void set_voice_MIC_silence_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°MICé™éŸ³è®¾ç½®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0) {
                      //mic å¼€å¯
                  }else {
                      //mic é™éŸ³
                  }
              }
              
              /**
               * @brief  speakeréŸ³é‡è®¾ç½®ç»“æœ
               * @param[in] {result} éŸ³é‡å€¼
               * @ref       0~10: éŸ³é‡èŒƒå›´
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void set_speaker_voice_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°speakeréŸ³é‡è®¾ç½®ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  
              }
              
              /**
               * @brief  éŸ³é¢‘äº§æµ‹ç»“æœ
               * @param[in] {result} éŸ³é¢‘äº§æµ‹çŠ¶æ€
               * @ref       0x00: å…³é—­éŸ³é¢‘äº§æµ‹
               * @ref       0x01: mic1éŸ³é¢‘ç¯è·¯æµ‹è¯•
               * @ref       0x02: mic2éŸ³é¢‘ç¯è·¯æµ‹è¯•
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°éŸ³é¢‘äº§æµ‹ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0x00) {
                      //å…³é—­éŸ³é¢‘äº§æµ‹
                  }else if(result == 0x01) {
                      //mic1éŸ³é¢‘ç¯è·¯æµ‹è¯•
                  }else if(result == 0x02) {
                      //mic2éŸ³é¢‘ç¯è·¯æµ‹è¯•
                  }
              }
              
              /**
               * @brief  å”¤é†’äº§æµ‹ç»“æœ
               * @param[in] {result} å”¤é†’è¿”å›å€¼
               * @ref       0x00: å”¤é†’æˆåŠŸ
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 21  

               * @ref       0x01: å”¤é†’å¤±è´¥(10sè¶…æ—¶å¤±è´¥)
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_awaken_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°å”¤é†’äº§æµ‹ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0x00) {
                      //å”¤é†’æˆåŠŸ
                  }else if(result == 0x01) {
                      //å”¤é†’å¤±è´¥
                  }
              }
              
              /**
               * @brief  è¯­éŸ³æ¨¡ç»„æ‰©å±•åŠŸèƒ½
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_module_extend_fun(const unsigned char value[], unsigned short length)
              {
                  unsigned char sub_cmd = value[0];
                  unsigned char play;
                  unsigned char bt_play;
                  unsigned short send_len = 0;
                
                  switch(sub_cmd) {
                      case 0x00: { //å­å‘½ä»¤  MCUåŠŸèƒ½è®¾ç½®
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x01: {  //å­å‘½ä»¤  çŠ¶æ€é€šçŸ¥
                          if(0x02 > length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          unsigned char play = 0xff;
                          unsigned char bt_play = 0xff;
                          
                          const char *str_buff = (const char *)&value[1];
                          const char *str_result = NULL;
                          
                          str_result = strstr(str_buff,"play") + my_strlen("play") + 2;
                          if(NULL == str_result) {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          if(0 == memcmp(str_result, "true", my_strlen("true"))) {
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 22  

                              play = 1;
                          }else if(0 == memcmp(str_result, "false", my_strlen("false"))) {
                              play = 0;
                          }else {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          str_result = strstr(str_buff,"bt_play") + my_strlen("bt_play") + 2;
                          if(NULL == str_result) {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          if(0 == memcmp(str_result, "true", my_strlen("true"))) {
                              bt_play = 1;
                          }else if(0 == memcmp(str_result, "false", my_strlen("false"))) {
                              bt_play = 0;
                          }else {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          #error "è¯·è‡ªè¡Œå®ç°è¯­éŸ³æ¨¡ç»„çŠ¶æ€é€šçŸ¥å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                          //MCUè®¾ç½®æš‚ä»…æ”¯æŒâ€æ’­æ”¾/æš‚åœâ€ â€è“ç‰™å¼€å…³â€
                          //play    æ’­æ”¾/æš‚åœåŠŸèƒ½  1(æ’­æ”¾) / 0(æš‚åœ)
                          //bt_play è“ç‰™å¼€å…³åŠŸèƒ½   1(å¼€)   / 0(å…³)
                          
                          
                          
                          send_len = 0;
                          send_len = set_wifi_uart_byte(send_len, sub_cmd);
                          send_len = set_wifi_uart_byte(send_len, 0x00);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
              
                      default:break;
                  }
                  
                  return;
              
              ERR_EXTI:
                  send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, sub_cmd);
                  send_len = set_wifi_uart_byte(send_len, 0x01);
                  wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                  return;
              }
              #endif
1329          
1330          
1331          
1332          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    458    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     18      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.56.0.0   PROTOCOL                                                          10/19/2020 14:26:54 PAGE 23  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
