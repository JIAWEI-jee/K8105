C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE PROTOCOL
OBJECT MODULE PLACED IN .\Objects\protocol.obj
COMPILER INVOKED BY: C:\program_list\keil\C51\BIN\C51.EXE ..\hardware\TUYA\protocol.c LARGE OPTIMIZE(8,SPEED) BROWSE INC
                    -DIR(..\hardware\DELAY;..\hardware\ADC;..\hardware\Flash;..\hardware\Uart;..\hardware\Key;..\hardware\Pwm;..\hardware\WDT
                    -;..\hardware\Timer;..\hardware\LCDdisplay;..\hardware\PID;..\hardware\TUYA) DEBUG OBJECTEXTEND PRINT(.\Listings\protocol
                    -.lst) TABS(2) OBJECT(.\Objects\protocol.obj)

line level    source

   1          /**********************************Copyright (c)**********************************
   2          **                       ç‰ˆæƒæ‰€æœ‰ (C), 2015-2020, æ¶‚é¸¦ç§‘æŠ€
   3          **
   4          **                             http://www.tuya.com
   5          **
   6          *********************************************************************************/
   7          /**
   8           * @file    protocol.c
   9           * @author  æ¶‚é¸¦ç»¼åˆåè®®å¼€å‘ç»„
  10           * @version v2.5.5
  11           * @date    2020.6.1
  12           * @brief                
  13           *                       *******éå¸¸é‡è¦ï¼Œä¸€å®šè¦çœ‹å“¦ï¼ï¼ï¼********
  14           *          1. ç”¨æˆ·åœ¨æ­¤æ–‡ä»¶ä¸­å®ç°æ•°æ®ä¸‹å‘/ä¸ŠæŠ¥åŠŸèƒ½
  15           *          2. DPçš„ID/TYPEåŠæ•°æ®å¤„ç†å‡½æ•°éƒ½éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…å®šä¹‰å®ç°
  16           *          3. å½“å¼€å§‹æŸäº›å®å®šä¹‰åéœ€è¦ç”¨æˆ·å®ç°ä»£ç çš„å‡½æ•°å†…éƒ¨æœ‰#erræç¤º,å®Œæˆå‡½æ•
             -°åè¯·åˆ é™¤è¯¥#err
  17           */
  18          
  19          /******************************************************************************
  20                                          ç§»æ¤é¡»çŸ¥:
  21          1:MCUå¿…é¡»åœ¨whileä¸­ç›´æ¥è°ƒç”¨mcu_api.cå†…çš„wifi_uart_service()å‡½æ•°
  22          2:ç¨‹åºæ­£å¸¸åˆå§‹åŒ–å®Œæˆå,å»ºè®®ä¸è¿›è¡Œå…³ä¸²å£ä¸­æ–­,å¦‚å¿…é¡»å…³ä¸­æ–­,å…³ä¸­æ–­æ—¶é—´å¿…é¡»çŸ
             -­,å…³ä¸­æ–­ä¼šå¼•èµ·ä¸²å£æ•°æ®åŒ…ä¸¢å¤±
  23          3:è¯·å‹¿åœ¨ä¸­æ–­/å®šæ—¶å™¨ä¸­æ–­å†…è°ƒç”¨ä¸ŠæŠ¥å‡½æ•°
  24          ******************************************************************************/
  25          
  26          #include "wifi.h"
  27          
  28          #ifdef WEATHER_ENABLE
              /**
               * @var    weather_choose
               * @brief  å¤©æ°”æ•°æ®å‚æ•°é€‰æ‹©æ•°ç»„
               * @note   ç”¨æˆ·å¯ä»¥è‡ªå®šä¹‰éœ€è¦çš„å‚æ•°ï¼Œæ³¨é‡Šæˆ–è€…å–æ¶ˆæ³¨é‡Šå³å¯ï¼Œæ³¨æ„æ›´æ”¹
               */
              const char *weather_choose[WEATHER_CHOOSE_CNT] = {
                  "temp",
                  "humidity",
                  "condition",
                  "pm25",
                  /*"pressure",
                  "realFeel",
                  "uvi",
                  "tips",
                  "windDir",
                  "windLevel",
                  "windSpeed",
                  "sunRise",
                  "sunSet",
                  "aqi",
                  "so2 ",
                  "rank",
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 2   

                  "pm10",
                  "o3",
                  "no2",
                  "co",*/
              };
              #endif
  57          
  58          
  59          /******************************************************************************
  60                                        ç¬¬ä¸€æ­¥:åˆå§‹åŒ–
  61          1:åœ¨éœ€è¦ä½¿ç”¨åˆ°wifiç›¸å…³æ–‡ä»¶çš„æ–‡ä»¶ä¸­include "wifi.h"
  62          2:åœ¨MCUåˆå§‹åŒ–ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶ä¸­çš„wifi_protocol_init()å‡½æ•°
  63          3:å°†MCUä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°å¡«å…¥protocol.cæ–‡ä»¶ä¸­uart_transmit_outputå‡½æ•°å†…,å¹¶åˆ é™¤#error
  64          4:åœ¨MCUä¸²å£æ¥æ”¶å‡½æ•°ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„uart_receive_inputå‡½æ•°,å¹¶å°†æ¥æ”¶åˆ°çš„å­—èŠ‚ä
             -½œä¸ºå‚æ•°ä¼ å…¥
  65          5:å•ç‰‡æœºè¿›å…¥whileå¾ªç¯åè°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„wifi_uart_service()å‡½æ•°
  66          ******************************************************************************/
  67          
  68          /******************************************************************************
  69                                  1:dpæ•°æ®ç‚¹åºåˆ—ç±»å‹å¯¹ç…§è¡¨
  70                    **æ­¤ä¸ºè‡ªåŠ¨ç”Ÿæˆä»£ç ,å¦‚åœ¨å¼€å‘å¹³å°æœ‰ç›¸å…³ä¿®æ”¹è¯·é‡æ–°ä¸‹è½½MCU_SDK**         
  71          ******************************************************************************/
  72          const DOWNLOAD_CMD_S download_cmd[] =
  73          {
  74            {DPID_SWITCH, DP_TYPE_BOOL},
  75            {DPID_TEMP_SET, DP_TYPE_VALUE},
  76            {DPID_TEMP_CURRENT, DP_TYPE_VALUE},
  77            {DPID_LEVEL, DP_TYPE_ENUM},
  78            {DPID_COUNTDOWN_SET, DP_TYPE_ENUM},
  79            {DPID_COUNTDOWN_LEFT, DP_TYPE_VALUE},
  80            {DPID_PREHEAT, DP_TYPE_BOOL},
  81            {DPID_FAULT, DP_TYPE_BITMAP},
  82            {DPID_PREHEAT_1, DP_TYPE_BOOL},
  83            {DPID_SKU, DP_TYPE_RAW},
  84          };
  85          
  86          
  87          
  88          /******************************************************************************
  89                                     2:ä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°
  90          è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°å†…,å¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥ä¸²å£å‘é€å‡½æ•°
  91          ******************************************************************************/
  92          
  93          /**
  94           * @brief  ä¸²å£å‘é€æ•°æ®
  95           * @param[in] {value} ä¸²å£è¦å‘é€çš„1å­—èŠ‚æ•°æ®
  96           * @return Null
  97           */
  98          void uart_transmit_output ( unsigned char value )
  99          {
 100   1      //    #error "è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°,å¹¶åˆ é™¤è¯¥è¡Œ"
 101   1        hal_uart_putchar ( value );
 102   1        /*
 103   1            //Example:
 104   1            extern void Uart_PutChar(unsigned char value);
 105   1            Uart_PutChar(value);                                  //ä¸²å£å‘é€å‡½æ•°
 106   1        */
 107   1      }
 108          
 109          /******************************************************************************
 110                                     ç¬¬äºŒæ­¥:å®ç°å…·ä½“ç”¨æˆ·å‡½æ•°
 111          1:APPä¸‹å‘æ•°æ®å¤„ç†
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 3   

 112          2:æ•°æ®ä¸ŠæŠ¥å¤„ç†
 113          ******************************************************************************/
 114          
 115          /******************************************************************************
 116                                      1:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 117          å½“å‰å‡½æ•°å¤„ç†å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥(åŒ…æ‹¬å¯ä¸‹å‘/å¯ä¸ŠæŠ¥å’Œåªä¸ŠæŠ¥)
 118            éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…æƒ…å†µå®ç°:
 119            1:éœ€è¦å®ç°å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 120            2:éœ€è¦å®ç°åªä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 121          æ­¤å‡½æ•°ä¸ºMCUå†…éƒ¨å¿…é¡»è°ƒç”¨
 122          ç”¨æˆ·ä¹Ÿå¯è°ƒç”¨æ­¤å‡½æ•°å®ç°å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥
 123          ******************************************************************************/
 124          
 125          //è‡ªåŠ¨åŒ–ç”Ÿæˆæ•°æ®ä¸ŠæŠ¥å‡½æ•°
 126          
 127          /**
 128           * @brief  ç³»ç»Ÿæ‰€æœ‰dpç‚¹ä¿¡æ¯ä¸Šä¼ ,å®ç°APPå’Œmucæ•°æ®åŒæ­¥
 129           * @param  Null
 130           * @return Null
 131           * @note   æ­¤å‡½æ•°SDKå†…éƒ¨éœ€è°ƒç”¨ï¼ŒMCUå¿…é¡»å®ç°è¯¥å‡½æ•°å†…æ•°æ®ä¸ŠæŠ¥åŠŸèƒ½ï¼ŒåŒ…æ‹¬åªä¸ŠæŠ¥å’
             -Œå¯ä¸ŠæŠ¥å¯ä¸‹å‘å‹æ•°æ®
 132           */
 133          void all_data_update(void)
 134          {
 135   1        u8 string[] = "K8105";
 136   1      //    #error "è¯·åœ¨æ­¤å¤„ç†å¯ä¸‹å‘å¯ä¸ŠæŠ¥æ•°æ®åŠåªä¸ŠæŠ¥æ•°æ®ç¤ºä¾‹,å¤„ç†å®Œæˆååˆ é™¤è¯¥è¡Œ"
 137   1      
 138   1        //æ­¤ä»£ç ä¸ºå¹³å°è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·æŒ‰ç…§å®é™…æ•°æ®ä¿®æ”¹æ¯ä¸ªå¯ä¸‹å‘å¯ä¸ŠæŠ¥å‡½æ•°å’Œåªä¸ŠæŠ¥å
             -‡½æ•°
 139   1        mcu_dp_bool_update ( DPID_SWITCH,get_device_state() ); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 140   1        mcu_dp_value_update ( DPID_TEMP_SET,25 ); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 141   1        mcu_dp_value_update ( DPID_TEMP_CURRENT,25 ); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 142   1        mcu_dp_enum_update ( DPID_LEVEL,flash_info.gap ); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 143   1        mcu_dp_enum_update ( DPID_COUNTDOWN_SET,0 ); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 144   1        mcu_dp_value_update ( DPID_COUNTDOWN_LEFT,0 ); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 145   1        mcu_dp_bool_update ( DPID_PREHEAT,0 ); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 146   1        mcu_dp_fault_update ( DPID_FAULT,0 ); //æ•…éšœå‹æ•°æ®ä¸ŠæŠ¥;
 147   1        mcu_dp_bool_update ( DPID_PREHEAT_1,0 ); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 148   1        mcu_dp_raw_update(DPID_SKU,string); //RAWå‹æ•°æ®ä¸ŠæŠ¥;
*** WARNING C209 IN LINE 148 OF ..\hardware\TUYA\protocol.c: '_mcu_dp_raw_update': too few actual parameters
 149   1      }
 150          
 151          
 152          /******************************************************************************
 153                                          WARNING!!!    
 154                                      2:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 155          è‡ªåŠ¨åŒ–ä»£ç æ¨¡æ¿å‡½æ•°,å…·ä½“è¯·ç”¨æˆ·è‡ªè¡Œå®ç°æ•°æ®å¤„ç†
 156          ******************************************************************************/
 157          /*****************************************************************************
 158          å‡½æ•°åç§° : dp_download_switch_handle
 159          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCHçš„å¤„ç†å‡½æ•°
 160          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 161                  : length:æ•°æ®é•¿åº¦
 162          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 163          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 164          *****************************************************************************/
 165          static unsigned char dp_download_switch_handle(const unsigned char value[], unsigned short length)
 166          {
 167   1        //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 168   1        unsigned char ret;
 169   1        //0:å…³/1:å¼€
 170   1        unsigned char switch_1;
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 4   

 171   1      
 172   1        switch_1 = mcu_get_dp_download_bool ( value,length );
 173   1        if ( switch_1 == 0 )
 174   1        {
 175   2          set_device_state ( OFF );
 176   2          //å¼€å…³å…³
 177   2        }
 178   1        else
 179   1        {
 180   2          //å¼€å…³å¼€
 181   2          set_device_state ( ON );
 182   2        }
 183   1      
 184   1        //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 185   1        ret = mcu_dp_bool_update ( DPID_SWITCH,switch_1 );
 186   1        if ( ret == SUCCESS )
 187   1        {
 188   2          return SUCCESS;
 189   2        }
 190   1        else
 191   1        {
 192   2          return ERROR;
 193   2        }
 194   1      }
 195          /*****************************************************************************
 196          å‡½æ•°åç§° : dp_download_temp_set_handle
 197          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_SETçš„å¤„ç†å‡½æ•°
 198          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 199                  : length:æ•°æ®é•¿åº¦
 200          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 201          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 202          *****************************************************************************/
 203          static unsigned char dp_download_temp_set_handle(const unsigned char value[], unsigned short length)
 204          {
 205   1        //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 206   1        unsigned char ret;
 207   1        unsigned long temp_set;
 208   1      
 209   1        temp_set = mcu_get_dp_download_value ( value,length );
 210   1        /*
 211   1        //VALUEç±»å‹æ•°æ®å¤„ç†
 212   1      
 213   1        */
 214   1      
 215   1        //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 216   1        ret = mcu_dp_value_update ( DPID_TEMP_SET,temp_set );
 217   1        if ( ret == SUCCESS )
 218   1        {
 219   2          return SUCCESS;
 220   2        }
 221   1        else
 222   1        {
 223   2          return ERROR;
 224   2        }
 225   1      }
 226          /*****************************************************************************
 227          å‡½æ•°åç§° : dp_download_level_handle
 228          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_LEVELçš„å¤„ç†å‡½æ•°
 229          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 230                  : length:æ•°æ®é•¿åº¦
 231          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 232          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 5   

 233          *****************************************************************************/
 234          static unsigned char dp_download_level_handle(const unsigned char value[], unsigned short length)
 235          {
 236   1        //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºENUM
 237   1        unsigned char ret;
 238   1        unsigned char level;
 239   1      
 240   1        level = mcu_get_dp_download_enum ( value,length );
 241   1        switch ( level )
 242   1        {
 243   2          case 0:
 244   2            flash_info.gap = GAP_1;
 245   2            break;
 246   2      
 247   2          case 1:
 248   2            flash_info.gap = GAP_2;
 249   2            break;
 250   2      
 251   2          case 2:
 252   2            flash_info.gap = GAP_3;
 253   2            break;
 254   2      
 255   2          case 3:
 256   2            flash_info.gap = GAP_4;
 257   2            break;
 258   2      
 259   2          case 4:
 260   2            flash_info.gap = GAP_5;
 261   2            break;
 262   2      
 263   2          case 5:
 264   2            flash_info.gap = GAP_6;
 265   2            break;
 266   2      
 267   2          case 6:
 268   2            flash_info.gap = GAP_7;
 269   2            break;
 270   2      
 271   2          case 7:
 272   2            flash_info.gap = GAP_8;
 273   2            break;
 274   2      
 275   2          case 8:
 276   2            flash_info.gap = GAP_9;
 277   2            break;
 278   2      
 279   2          default:
 280   2      
 281   2            break;
 282   2        }
 283   1          flah_save_data();
 284   1        //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 285   1        ret = mcu_dp_enum_update ( DPID_LEVEL, level );
 286   1        if ( ret == SUCCESS )
 287   1        {
 288   2          return SUCCESS;
 289   2        }
 290   1        else
 291   1        {
 292   2          return ERROR;
 293   2        }
 294   1      }
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 6   

 295          /*****************************************************************************
 296          å‡½æ•°åç§° : dp_download_countdown_set_handle
 297          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_COUNTDOWN_SETçš„å¤„ç†å‡½æ•°
 298          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 299                  : length:æ•°æ®é•¿åº¦
 300          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 301          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 302          *****************************************************************************/
 303          static unsigned char dp_download_countdown_set_handle(const unsigned char value[], unsigned short length)
 304          {
 305   1        //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºENUM
 306   1        unsigned char ret;
 307   1        unsigned char countdown_set;
 308   1      
 309   1        countdown_set = mcu_get_dp_download_enum ( value,length );
 310   1        switch ( countdown_set )
 311   1        {
 312   2          case 0:
 313   2            flash_info.timer = TIMER_ON;
 314   2            break;
 315   2      
 316   2          case 1:
 317   2            flash_info.timer = TIMER_0_5H;
 318   2            break;
 319   2      
 320   2          case 2:
 321   2            flash_info.timer = TIMER_1H;
 322   2            break;
 323   2      
 324   2          case 3:
 325   2            flash_info.timer = TIMER_2H;
 326   2            break;
 327   2      
 328   2          case 4:
 329   2            flash_info.timer = TIMER_4H;
 330   2            break;
 331   2      
 332   2          case 5:
 333   2            flash_info.timer = TIMER_8H;
 334   2            break;
 335   2      
 336   2          default:
 337   2      
 338   2            break;
 339   2        }
 340   1      
 341   1        //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 342   1        ret = mcu_dp_enum_update ( DPID_COUNTDOWN_SET, countdown_set );
 343   1        if ( ret == SUCCESS )
 344   1        {
 345   2          return SUCCESS;
 346   2        }
 347   1        else
 348   1        {
 349   2          return ERROR;
 350   2        }
 351   1      }
 352          /*****************************************************************************
 353          å‡½æ•°åç§° : dp_download_preheat_handle
 354          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_PREHEATçš„å¤„ç†å‡½æ•°
 355          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 356                  : length:æ•°æ®é•¿åº¦
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 7   

 357          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 358          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 359          *****************************************************************************/
 360          static unsigned char dp_download_preheat_handle(const unsigned char value[], unsigned short length)
 361          {
 362   1        //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 363   1        unsigned char ret;
 364   1        //0:å…³/1:å¼€
 365   1        unsigned char preheat;
 366   1      
 367   1        preheat = mcu_get_dp_download_bool ( value,length );
 368   1        if ( preheat == 0 )
 369   1        {
 370   2          //å¼€å…³å…³
 371   2          Heat_start_std = 1;
 372   2          heat_step = 0;
 373   2        }
 374   1        else
 375   1        {
 376   2          //å¼€å…³å¼€
 377   2          Heat_start_std = 1;
 378   2          heat_step = 1;
 379   2        }
 380   1      
 381   1        //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 382   1        ret = mcu_dp_bool_update ( DPID_PREHEAT,preheat );
 383   1        if ( ret == SUCCESS )
 384   1        {
 385   2          return SUCCESS;
 386   2        }
 387   1        else
 388   1        {
 389   2          return ERROR;
 390   2        }
 391   1      }
 392          /*****************************************************************************
 393          å‡½æ•°åç§° : dp_download_preheat_1_handle
 394          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_PREHEAT_1çš„å¤„ç†å‡½æ•°
 395          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 396                  : length:æ•°æ®é•¿åº¦
 397          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 398          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 399          *****************************************************************************/
 400          static unsigned char dp_download_preheat_1_handle(const unsigned char value[], unsigned short length)
 401          {
 402   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 403   1          unsigned char ret;
 404   1          //0:å…³/1:å¼€
 405   1          unsigned char preheat_1;
 406   1          
 407   1          preheat_1 = mcu_get_dp_download_bool(value,length);
 408   1          if(preheat_1 == 0) {
 409   2              //å¼€å…³å…³
 410   2          }else {
 411   2              //å¼€å…³å¼€
 412   2          }
 413   1        
 414   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 415   1          ret = mcu_dp_bool_update(DPID_PREHEAT_1,preheat_1);
 416   1          if(ret == SUCCESS)
 417   1              return SUCCESS;
 418   1          else
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 8   

 419   1              return ERROR;
 420   1      }
 421          /*****************************************************************************
 422          å‡½æ•°åç§° : dp_download_sku_handle
 423          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SKUçš„å¤„ç†å‡½æ•°
 424          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 425                  : length:æ•°æ®é•¿åº¦
 426          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 427          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 428          *****************************************************************************/
 429          static unsigned char dp_download_sku_handle(const unsigned char value[], unsigned short length)
 430          {
 431   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºRAW
 432   1          unsigned char ret;
 433   1          /*
 434   1          //RAWç±»å‹æ•°æ®å¤„ç†
 435   1          
 436   1          */
 437   1          
 438   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 439   1          ret = mcu_dp_raw_update(DPID_SKU,value,length);
 440   1          if(ret == SUCCESS)
 441   1              return SUCCESS;
 442   1          else
 443   1              return ERROR;
 444   1      }
 445          
 446          
 447          
 448          
 449          /******************************************************************************
 450                                          WARNING!!!                     
 451          æ­¤éƒ¨åˆ†å‡½æ•°ç”¨æˆ·è¯·å‹¿ä¿®æ”¹!!
 452          ******************************************************************************/
 453          
 454          /**
 455           * @brief  dpä¸‹å‘å¤„ç†å‡½æ•°
 456           * @param[in] {dpid} dpid åºå·
 457           * @param[in] {value} dpæ•°æ®ç¼“å†²åŒºåœ°å€
 458           * @param[in] {length} dpæ•°æ®é•¿åº¦
 459           * @return dpå¤„ç†ç»“æœ
 460           * -           0(ERROR): å¤±è´¥
 461           * -           1(SUCCESS): æˆåŠŸ
 462           * @note   è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 463           */
 464          unsigned char dp_download_handle(unsigned char dpid,const unsigned char value[], unsigned short length)
 465          {
 466   1          /*********************************
 467   1          å½“å‰å‡½æ•°å¤„ç†å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®è°ƒç”¨                    
 468   1          å…·ä½“å‡½æ•°å†…éœ€è¦å®ç°ä¸‹å‘æ•°æ®å¤„ç†
 469   1          å®Œæˆç”¨éœ€è¦å°†å¤„ç†ç»“æœåé¦ˆè‡³APPç«¯,å¦åˆ™APPä¼šè®¤ä¸ºä¸‹å‘å¤±è´¥
 470   1          ***********************************/
 471   1          unsigned char ret;
 472   1          switch(dpid) {
 473   2              case DPID_SWITCH:
 474   2                  //å¼€å…³å¤„ç†å‡½æ•°
 475   2                  ret = dp_download_switch_handle(value,length);
 476   2              break;
 477   2              case DPID_TEMP_SET:
 478   2                  //æ¸©åº¦è®¾ç½®å¤„ç†å‡½æ•°
 479   2                  ret = dp_download_temp_set_handle(value,length);
 480   2              break;
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 9   

 481   2              case DPID_LEVEL:
 482   2                  //æ¡£ä½å¤„ç†å‡½æ•°
 483   2                  ret = dp_download_level_handle(value,length);
 484   2              break;
 485   2              case DPID_COUNTDOWN_SET:
 486   2                  //å€’è®¡æ—¶å¤„ç†å‡½æ•°
 487   2                  ret = dp_download_countdown_set_handle(value,length);
 488   2              break;
 489   2              case DPID_PREHEAT:
 490   2                  //æ˜¯å¦é¢„çƒ­å¤„ç†å‡½æ•°
 491   2                  ret = dp_download_preheat_handle(value,length);
 492   2              break;
 493   2              case DPID_PREHEAT_1:
 494   2                  //é¢„çƒ­1å¤„ç†å‡½æ•°
 495   2                  ret = dp_download_preheat_1_handle(value,length);
 496   2              break;
 497   2              case DPID_SKU:
 498   2                  //å‹å·å¤„ç†å‡½æ•°
 499   2                  ret = dp_download_sku_handle(value,length);
 500   2              break;
 501   2      
 502   2              
 503   2              default:
 504   2              break;
 505   2          }
 506   1          return ret;
 507   1      }
 508          
 509          /**
 510           * @brief  è·å–æ‰€æœ‰dpå‘½ä»¤æ€»å’Œ
 511           * @param[in] Null
 512           * @return ä¸‹å‘å‘½ä»¤æ€»å’Œ
 513           * @note   è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 514           */
 515          unsigned char get_download_cmd_total(void)
 516          {
 517   1          return(sizeof(download_cmd) / sizeof(download_cmd[0]));
 518   1      }
 519          
 520          
 521          /******************************************************************************
 522                                          WARNING!!!                     
 523          æ­¤ä»£ç ä¸ºSDKå†…éƒ¨è°ƒç”¨,è¯·æŒ‰ç…§å®é™…dpæ•°æ®å®ç°å‡½æ•°å†…éƒ¨æ•°æ®
 524          ******************************************************************************/
 525          
 526          #ifdef SUPPORT_MCU_FIRM_UPDATE
              /**
               * @brief  å‡çº§åŒ…å¤§å°é€‰æ‹©
               * @param[in] {package_sz} å‡çº§åŒ…å¤§å°
               * @ref           0x00: 256byte (é»˜è®¤)
               * @ref           0x01: 512byte
               * @ref           0x02: 1024byte
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void upgrade_package_choose(unsigned char package_sz)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è¯·è‡ªè¡Œå®ç°å‡çº§åŒ…å¤§å°é€‰æ‹©ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned short send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, package_sz);
                  wifi_uart_write_frame(UPDATE_START_CMD, MCU_TX_VER, send_len);
              }
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 10  

              
              /**
               * @brief  MCUè¿›å…¥å›ºä»¶å‡çº§æ¨¡å¼
               * @param[in] {value} å›ºä»¶ç¼“å†²åŒº
               * @param[in] {position} å½“å‰æ•°æ®åŒ…åœ¨äºå›ºä»¶ä½ç½®
               * @param[in] {length} å½“å‰å›ºä»¶åŒ…é•¿åº¦(å›ºä»¶åŒ…é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºå›ºä»¶åŒ…å‘é€å®Œæˆ)
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              unsigned char mcu_firm_update_handle(const unsigned char value[],unsigned long position,unsigned short len
             -gth)
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆMCUå›ºä»¶å‡çº§ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(length == 0) {
                      //å›ºä»¶æ•°æ®å‘é€å®Œæˆ
                    
                  }else {
                      //å›ºä»¶æ•°æ®å¤„ç†
                    
                  }
                  
                  return SUCCESS;
              }
              #endif
 566          
 567          #ifdef SUPPORT_GREEN_TIME
              /**
               * @brief  è·å–åˆ°çš„æ ¼æ—æ—¶é—´
               * @param[in] {time} è·å–åˆ°çš„æ ¼æ—æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_get_greentime(unsigned char time[])
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆç›¸å…³ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  time[0] ä¸ºæ˜¯å¦è·å–æ—¶é—´æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1è¡¨ç¤ºæˆåŠŸ
                  time[1] ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º 2000 å¹´
                  time[2] ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                  time[3] ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                  time[4] ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                  time[5] ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  time[6] ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  */
                  if(time[0] == 1) {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„æ ¼æ—æ•°æ®
                      
                  }else {
                      //è·å–æ ¼æ—æ—¶é—´å‡ºé”™,æœ‰å¯èƒ½æ˜¯å½“å‰wifiæ¨¡å—æœªè”ç½‘
                  }
              }
              #endif
 594          
 595          #ifdef SUPPORT_MCU_RTC_CHECK
              /**
               * @brief  MCUæ ¡å¯¹æœ¬åœ°RTCæ—¶é’Ÿ
               * @param[in] {time} è·å–åˆ°çš„æ ¼æ—æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_write_rtctime(unsigned char time[])
              {
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 11  

                  #error "è¯·è‡ªè¡Œå®ŒæˆRTCæ—¶é’Ÿå†™å…¥ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  Time[0] ä¸ºæ˜¯å¦è·å–æ—¶é—´æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1è¡¨ç¤ºæˆåŠŸ
                  Time[1] ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º 2000 å¹´
                  Time[2] ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                  Time[3] ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                  Time[4] ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                  Time[5] ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  Time[6] ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  Time[7] ä¸ºæ˜ŸæœŸï¼Œä» 1 å¼€å§‹åˆ° 7 ç»“æŸï¼Œ1ä»£è¡¨æ˜ŸæœŸä¸€
                 */
                  if(time[0] == 1) {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„æœ¬åœ°æ—¶é’Ÿæ•°æ®
                   
                  }else {
                      //è·å–æœ¬åœ°æ—¶é’Ÿæ•°æ®å‡ºé”™,æœ‰å¯èƒ½æ˜¯å½“å‰wifiæ¨¡å—æœªè”ç½‘
                  }
              }
              #endif
 623          
 624          #ifdef WIFI_TEST_ENABLE
 625          /**
 626           * @brief  wifiåŠŸèƒ½æµ‹è¯•åé¦ˆ
 627           * @param[in] {result} wifiåŠŸèƒ½æµ‹è¯•ç»“æœ
 628           * @ref       0: å¤±è´¥
 629           * @ref       1: æˆåŠŸ
 630           * @param[in] {rssi} æµ‹è¯•æˆåŠŸè¡¨ç¤ºwifiä¿¡å·å¼ºåº¦/æµ‹è¯•å¤±è´¥è¡¨ç¤ºé”™è¯¯ç±»å‹
 631           * @return Null
 632           * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
 633           */
 634          void wifi_test_result(unsigned char result,unsigned char rssi)
 635          {
 636   1      //    #error "è¯·è‡ªè¡Œå®ç°wifiåŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
 637   1        if ( result == 0 )
 638   1        {
 639   2          //æµ‹è¯•å¤±è´¥
 640   2          if ( rssi == 0x00 )
 641   2          {
 642   3            //æœªæ‰«æåˆ°åç§°ä¸ºtuya_mdev_testè·¯ç”±å™¨,è¯·æ£€æŸ¥
 643   3          }
 644   2          else if ( rssi == 0x01 )
 645   2          {
 646   3            //æ¨¡å—æœªæˆæƒ
 647   3          }
 648   2        }
 649   1        else
 650   1        {
 651   2          //æµ‹è¯•æˆåŠŸ
 652   2          //rssiä¸ºä¿¡å·å¼ºåº¦(0-100, 0ä¿¡å·æœ€å·®ï¼Œ100ä¿¡å·æœ€å¼º)
 653   2        }
 654   1      }
 655          #endif
 656          
 657          #ifdef WEATHER_ENABLE
              /**
              * @brief  mcuæ‰“å¼€å¤©æ°”æœåŠ¡
               * @param  Null
               * @return Null
               */
              void mcu_open_weather(void)
              {
                  int i = 0;
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 12  

                  char buffer[13] = {0};
                  unsigned char weather_len = 0;
                  unsigned short send_len = 0;
                  
                  weather_len = sizeof(weather_choose) / sizeof(weather_choose[0]);
                    
                  for(i=0;i<weather_len;i++) {
                      buffer[0] = sprintf(buffer+1,"w.%s",weather_choose[i]);
                      send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  }
                  
                  #error "è¯·æ ¹æ®æç¤ºï¼Œè‡ªè¡Œå®Œå–„æ‰“å¼€å¤©æ°”æœåŠ¡ä»£ç ï¼Œå®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  /*
                  //å½“è·å–çš„å‚æ•°æœ‰å’Œæ—¶é—´æœ‰å…³çš„å‚æ•°æ—¶(å¦‚:æ—¥å‡ºæ—¥è½)ï¼Œéœ€è¦æ­é…t.unixæˆ–è€…t.local
             -ä½¿ç”¨ï¼Œéœ€è¦è·å–çš„å‚æ•°æ•°æ®æ˜¯æŒ‰ç…§æ ¼æ—æ—¶é—´è¿˜æ˜¯æœ¬åœ°æ—¶é—´
                  buffer[0] = sprintf(buffer+1,"t.unix"); //æ ¼æ—æ—¶é—´   æˆ–ä½¿ç”¨  buffer[0] = sprintf(buffer+1,"t.lo
             -cal"); //æœ¬åœ°æ—¶é—´
                  send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  */
                  
                  buffer[0] = sprintf(buffer+1,"w.date.%d",WEATHER_FORECAST_DAYS_NUM);
                  send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  
                  wifi_uart_write_frame(WEATHER_OPEN_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  æ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›ç”¨æˆ·è‡ªå¤„ç†å‡½æ•°
               * @param[in] {res} æ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›ç»“æœ
               * @ref       0: å¤±è´¥
               * @ref       1: æˆåŠŸ
               * @param[in] {err} é”™è¯¯ç 
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void weather_open_return_handle(unsigned char res, unsigned char err)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆæ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›æ•°æ®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char err_num = 0;
                  
                  if(res == 1) {
                      //æ‰“å¼€å¤©æ°”è¿”å›æˆåŠŸ
                  }else if(res == 0) {
                      //æ‰“å¼€å¤©æ°”è¿”å›å¤±è´¥
                      //è·å–é”™è¯¯ç 
                      err_num = err; 
                  }
              }
              
              /**
               * @brief  å¤©æ°”æ•°æ®ç”¨æˆ·è‡ªå¤„ç†å‡½æ•°
               * @param[in] {name} å‚æ•°å
               * @param[in] {type} å‚æ•°ç±»å‹
               * @ref       0: int å‹
               * @ref       1: string å‹
               * @param[in] {data} å‚æ•°å€¼çš„åœ°å€
               * @param[in] {day} å“ªä¸€å¤©çš„å¤©æ°”  0:è¡¨ç¤ºå½“å¤© å–å€¼èŒƒå›´: 0~6
               * @ref       0: ä»Šå¤©
               * @ref       1: æ˜å¤©
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 13  

              void weather_data_user_handle(char *name, unsigned char type, const unsigned char *data, char day)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„å¤©æ°”æ•°æ®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  int value_int;
                  char value_string[50];//ç”±äºæœ‰çš„å‚æ•°å†…å®¹è¾ƒå¤šï¼Œè¿™é‡Œé»˜è®¤ä¸º50ã€‚æ‚¨å¯ä»¥æ ¹æ®å®šä¹‰çš„å
             -‚æ•°ï¼Œå¯ä»¥é€‚å½“å‡å°‘è¯¥å€¼
                  
                  my_memset(value_string, '\0', 50);
                  
                  //é¦–å…ˆè·å–æ•°æ®ç±»å‹
                  if(type == 0) { //å‚æ•°æ˜¯INTå‹
                      value_int = data[0] << 24 | data[1] << 16 | data[2] << 8 | data[3];
                  }else if(type == 1) {
                      my_strcpy(value_string, data);
                  }
                  
                  //æ³¨æ„è¦æ ¹æ®æ‰€é€‰å‚æ•°ç±»å‹æ¥è·å¾—å‚æ•°å€¼ï¼ï¼ï¼
                  if(my_strcmp(name, "temp") == 0) {
                      printf("day:%d temp value is:%d\r\n", day, value_int);          //int å‹
                  }else if(my_strcmp(name, "humidity") == 0) {
                      printf("day:%d humidity value is:%d\r\n", day, value_int);      //int å‹
                  }else if(my_strcmp(name, "pm25") == 0) {
                      printf("day:%d pm25 value is:%d\r\n", day, value_int);          //int å‹
                  }else if(my_strcmp(name, "condition") == 0) {
                      printf("day:%d condition value is:%s\r\n", day, value_string);  //string å‹
                  }
              }
              #endif
 753          
 754          #ifdef MCU_DP_UPLOAD_SYN
              /**
               * @brief  çŠ¶æ€åŒæ­¥ä¸ŠæŠ¥ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0: å¤±è´¥
               * @ref       1: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_upload_syn_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆçŠ¶æ€åŒæ­¥ä¸ŠæŠ¥ç»“æœä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                    
                  if(result == 0) {
                      //åŒæ­¥ä¸ŠæŠ¥å‡ºé”™
                  }else {
                      //åŒæ­¥ä¸ŠæŠ¥æˆåŠŸ
                  }
              }
              #endif
 774          
 775          #ifdef GET_WIFI_STATUS_ENABLE
              /**
               * @brief  è·å– WIFI çŠ¶æ€ç»“æœ
               * @param[in] {result} æŒ‡ç¤º WIFI å·¥ä½œçŠ¶æ€
               * @ref       0x00: wifiçŠ¶æ€ 1 smartconfig é…ç½®çŠ¶æ€
               * @ref       0x01: wifiçŠ¶æ€ 2 AP é…ç½®çŠ¶æ€
               * @ref       0x02: wifiçŠ¶æ€ 3 WIFI å·²é…ç½®ä½†æœªè¿ä¸Šè·¯ç”±å™¨
               * @ref       0x03: wifiçŠ¶æ€ 4 WIFI å·²é…ç½®ä¸”è¿ä¸Šè·¯ç”±å™¨
               * @ref       0x04: wifiçŠ¶æ€ 5 å·²è¿ä¸Šè·¯ç”±å™¨ä¸”è¿æ¥åˆ°äº‘ç«¯
               * @ref       0x05: wifiçŠ¶æ€ 6 WIFI è®¾å¤‡å¤„äºä½åŠŸè€—æ¨¡å¼
               * @ref       0x06: wifiçŠ¶æ€ 7 WIFI è®¾å¤‡å¤„äºsmartconfig&APé…ç½®çŠ¶æ€
               * @return Null
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 14  

               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_wifi_status(unsigned char result)
              {
                #error "è¯·è‡ªè¡Œå®Œæˆè·å– WIFI çŠ¶æ€ç»“æœä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
               
                  switch(result) {
                      case 0:
                          //wifiå·¥ä½œçŠ¶æ€1
                      break;
                  
                      case 1:
                          //wifiå·¥ä½œçŠ¶æ€2
                      break;
                      
                      case 2:
                          //wifiå·¥ä½œçŠ¶æ€3
                      break;
                      
                      case 3:
                          //wifiå·¥ä½œçŠ¶æ€4
                      break;
                      
                      case 4:
                          //wifiå·¥ä½œçŠ¶æ€5
                      break;
                      
                      case 5:
                          //wifiå·¥ä½œçŠ¶æ€6
                      break;
                    
                      case 6:
                          //wifiå·¥ä½œçŠ¶æ€7
                      break;
                      
                      default:break;
                  }
              }
              #endif
 826          
 827          #ifdef WIFI_STREAM_ENABLE
              /**
               * @brief  æµæœåŠ¡å‘é€ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0x00: æˆåŠŸ
               * @ref       0x01: æµæœåŠ¡åŠŸèƒ½æœªå¼€å¯
               * @ref       0x02: æµæœåŠ¡å™¨æœªè¿æ¥æˆåŠŸ
               * @ref       0x03: æ•°æ®æ¨é€è¶…æ—¶
               * @ref       0x04: ä¼ è¾“çš„æ•°æ®é•¿åº¦é”™è¯¯
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void stream_trans_send_result(unsigned char result)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„æµæœåŠ¡å‘é€ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥
             -è¡Œ"
                  switch(result) {
                      case 0x00:
                          //æˆåŠŸ
                      break;
                      
                      case 0x01:
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 15  

                          //æµæœåŠ¡åŠŸèƒ½æœªå¼€å¯
                      break;
                      
                      case 0x02:
                          //æµæœåŠ¡å™¨æœªè¿æ¥æˆåŠŸ
                      break;
                      
                      case 0x03:
                          //æ•°æ®æ¨é€è¶…æ—¶
                      break;
                      
                      case 0x04:
                          //ä¼ è¾“çš„æ•°æ®é•¿åº¦é”™è¯¯
                      break;
                      
                      default:break;
                  }
              }
              
              /**
               * @brief  å¤šåœ°å›¾æµæœåŠ¡å‘é€ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0x00: æˆåŠŸ
               * @ref       0x01: å¤±è´¥
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void maps_stream_trans_send_result(unsigned char result)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„å¤šåœ°å›¾æµæœåŠ¡å‘é€ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·
             -åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0x00:
                          //æˆåŠŸ
                      break;
                      
                      case 0x01:
                          //å¤±è´¥
                      break;
                      
                      default:break;
                  }
              }
              #endif
 891          
 892          #ifdef WIFI_CONNECT_TEST_ENABLE
              /**
               * @brief  è·¯ç”±ä¿¡æ¯æ¥æ”¶ç»“æœé€šçŸ¥
               * @param[in] {result} æ¨¡å—æ˜¯å¦æˆåŠŸæ¥æ”¶åˆ°æ­£ç¡®çš„è·¯ç”±ä¿¡æ¯
               * @ref       0x00: å¤±è´¥
               * @ref       0x01: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void wifi_connect_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°wifiåŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0) {
                      //è·¯ç”±ä¿¡æ¯æ¥æ”¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘å‡ºçš„è·¯ç”±ä¿¡æ¯åŒ…æ˜¯å¦æ˜¯å®Œæ•´çš„JSONæ•°æ®åŒ…
                  }else {
                      //è·¯ç”±ä¿¡æ¯æ¥æ”¶æˆåŠŸï¼Œäº§æµ‹ç»“æœè¯·æ³¨æ„WIFI_STATE_CMDæŒ‡ä»¤çš„wifiå·¥ä½œçŠ¶æ€
                  }
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 16  

              }
              #endif
 911          
 912          #ifdef GET_MODULE_MAC_ENABLE
              /**
               * @brief  è·å–æ¨¡å—macç»“æœ
               * @param[in] {mac} æ¨¡å— MAC æ•°æ®
               * @ref       mac[0]: ä¸ºæ˜¯å¦è·å–macæˆåŠŸæ ‡å¿—ï¼Œ0x00 è¡¨ç¤ºæˆåŠŸï¼Œ0x01 è¡¨ç¤ºå¤±è´¥
               * @ref       mac[1]~mac[6]: å½“è·å– MACåœ°å€æ ‡å¿—ä½å¦‚æœmac[0]ä¸ºæˆåŠŸï¼Œåˆ™è¡¨ç¤ºæ¨¡å—æœ‰æ•ˆçš„M
             -ACåœ°å€
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_get_mac(unsigned char mac[])
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆmacè·å–ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  mac[0]ä¸ºæ˜¯å¦è·å–macæˆåŠŸæ ‡å¿—ï¼Œ0x00 è¡¨ç¤ºæˆåŠŸï¼Œä¸º0x01è¡¨ç¤ºå¤±è´¥
                  mac[1]~mac[6]:å½“è·å– MACåœ°å€æ ‡å¿—ä½å¦‚æœmac[0]ä¸ºæˆåŠŸï¼Œåˆ™è¡¨ç¤ºæ¨¡å—æœ‰æ•ˆçš„MACåœ°å€
                 */
                 
                  if(mac[0] == 1) {
                      //è·å–macå‡ºé”™
                  }else {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„macåœ°å€
                  }
              }
              #endif
 936          
 937          #ifdef GET_IR_STATUS_ENABLE
              /**
               * @brief  è·å–çº¢å¤–çŠ¶æ€ç»“æœ
               * @param[in] {result} æŒ‡ç¤ºçº¢å¤–çŠ¶æ€
               * @ref       0x00: çº¢å¤–çŠ¶æ€ 1 æ­£åœ¨å‘é€çº¢å¤–ç 
               * @ref       0x01: çº¢å¤–çŠ¶æ€ 2 å‘é€çº¢å¤–ç ç»“æŸ
               * @ref       0x02: çº¢å¤–çŠ¶æ€ 3 çº¢å¤–å­¦ä¹ å¼€å§‹
               * @ref       0x03: çº¢å¤–çŠ¶æ€ 4 çº¢å¤–å­¦ä¹ ç»“æŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_ir_status(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆçº¢å¤–çŠ¶æ€ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0:
                          //çº¢å¤–çŠ¶æ€ 1
                      break;
                    
                      case 1:
                          //çº¢å¤–çŠ¶æ€ 2
                      break;
                        
                      case 2:
                          //çº¢å¤–çŠ¶æ€ 3
                      break;
                        
                      case 3:
                          //çº¢å¤–çŠ¶æ€ 4
                      break;
                        
                      default:break;
                  }
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 17  

                  
                  wifi_uart_write_frame(GET_IR_STATUS_CMD, MCU_TX_VER, 0);
              }
              #endif
 974          
 975          #ifdef IR_TX_RX_TEST_ENABLE
              /**
               * @brief  çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹ç»“æœé€šçŸ¥
               * @param[in] {result} æ¨¡å—æ˜¯å¦æˆåŠŸæ¥æ”¶åˆ°æ­£ç¡®çš„ä¿¡æ¯
               * @ref       0x00: å¤±è´¥
               * @ref       0x01: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void ir_tx_rx_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹åŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡
             -Œ"
                  if(result == 0) {
                      //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹æˆåŠŸ
                  }else {
                      //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘å‡ºçš„æ•°æ®åŒ…
                  }
              }
              #endif
 994          
 995          #ifdef FILE_DOWNLOAD_ENABLE
              /**
               * @brief  æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°é€‰æ‹©
               * @param[in] {package_sz} æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°
               * @ref       0x00: 256 byte (é»˜è®¤)
               * @ref       0x01: 512 byte
               * @ref       0x02: 1024 byte
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void file_download_package_choose(unsigned char package_sz)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è¯·è‡ªè¡Œå®ç°æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°é€‰æ‹©ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned short send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, package_sz);
                  wifi_uart_write_frame(FILE_DOWNLOAD_START_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  æ–‡ä»¶åŒ…ä¸‹è½½æ¨¡å¼
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {position} å½“å‰æ•°æ®åŒ…åœ¨äºæ–‡ä»¶ä½ç½®
               * @param[in] {length} å½“å‰æ–‡ä»¶åŒ…é•¿åº¦(é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºæ–‡ä»¶åŒ…å‘é€å®Œæˆ)
               * @return æ•°æ®å¤„ç†ç»“æœ
               * -           0(ERROR): å¤±è´¥
               * -           1(SUCCESS): æˆåŠŸ
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              unsigned char file_download_handle(const unsigned char value[],unsigned long position,unsigned short lengt
             -h)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆæ–‡ä»¶åŒ…ä¸‹è½½ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(length == 0) {
                      //æ–‡ä»¶åŒ…æ•°æ®å‘é€å®Œæˆ
                      
                  }else {
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 18  

                      //æ–‡ä»¶åŒ…æ•°æ®å¤„ç†
                    
                  }
                  
                  return SUCCESS;
              }
              #endif
1037          
1038          #ifdef MODULE_EXPANDING_SERVICE_ENABLE
              /**
               * @brief  æ‰“å¼€æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥ç»“æœ
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void open_module_time_serve_result(const unsigned char value[], unsigned short length)
              {
                  #error "è¯·è‡ªè¡Œå®ç°æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥ç»“æœä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char sub_cmd = value[0];
                  
                  switch(sub_cmd) {
                      case 0x01: { //å­å‘½ä»¤  æ‰“å¼€æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æœåŠ¡å¼€å¯æˆåŠŸ
                          }else {
                              //æœåŠ¡å¼€å¯å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x02: {  //å­å‘½ä»¤  æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥
                          if(0x09 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          unsigned char time_type = value[1]; //0x00:æ ¼æ—æ—¶é—´  0x01:æœ¬åœ°æ—¶é—´
                          unsigned char time_data[7];
                          
                          my_memcpy(time_data, value + 2, length - 2);
                          /*
                          Data[0]ä¸ºå¹´ä»½, 0x00è¡¨ç¤º2000å¹´
                          Data[1]ä¸ºæœˆä»½ï¼Œä»1å¼€å§‹åˆ°12ç»“æŸ
                          Data[2]ä¸ºæ—¥æœŸï¼Œä»1å¼€å§‹åˆ°31ç»“æŸ
                          Data[3]ä¸ºæ—¶é’Ÿï¼Œä»0å¼€å§‹åˆ°23ç»“æŸ
                          Data[4]ä¸ºåˆ†é’Ÿï¼Œä»0å¼€å§‹åˆ°59ç»“æŸ
                          Data[5]ä¸ºç§’é’Ÿï¼Œä»0å¼€å§‹åˆ°15ç»“æŸ
                          Data[6]ä¸ºæ˜ŸæœŸï¼Œä»1å¼€å§‹åˆ°7ç»“æŸï¼Œ1ä»£è¡¨æ˜ŸæœŸä¸€
                          */
                          
                          //åœ¨æ­¤å¤„æ·»åŠ æ—¶é—´æ•°æ®å¤„ç†ä»£ç ï¼Œtime_typeä¸ºæ—¶é—´ç±»å‹
                          
                          unsigned short send_len = 0;
                          send_len = set_wifi_uart_byte(send_len,sub_cmd);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 19  

                      break;
                      
                      case 0x03: {  //å­å‘½ä»¤  ä¸»åŠ¨è¯·æ±‚å¤©æ°”æœåŠ¡æ•°æ®
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x04: {  //å­å‘½ä»¤  æ‰“å¼€æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x05: {  //å­å‘½ä»¤  æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          switch(value[1]) {
                              case 0x00:
                                  //æ¨¡å—æœ¬åœ°é‡ç½®
                                  
                              break;
                              case 0x01:
                                  //APPè¿œç¨‹é‡ç½®
                                  
                              break;
                              case 0x02:
                                  //APPæ¢å¤å‡ºå‚é‡ç½®
                                  
                              break;
                              default:break;
                          }
                          
                          unsigned short send_len = 0;
                          send_len = set_wifi_uart_byte(send_len, sub_cmd);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
                      
                      default:break;
                  }
              }
              #endif
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 20  

1154          
1155          #ifdef BLE_RELATED_FUNCTION_ENABLE
              /**
               * @brief  è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ç»“æœ
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void BLE_test_result(const unsigned char value[], unsigned short length)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ç»“æœä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char sub_cmd = value[0];
                  
                  if(0x03 != length) {
                      //æ•°æ®é•¿åº¦é”™è¯¯
                      return;
                  }
                  
                  if(0x01 != sub_cmd) {
                      //å­å‘½ä»¤é”™è¯¯
                      return;
                  }
                  
                  unsigned char result = value[1];
                  unsigned char rssi = value[2];
                      
                  if(result == 0) {
                      //æµ‹è¯•å¤±è´¥
                      if(rssi == 0x00) {
                          //æœªæ‰«æåˆ°åç§°ä¸º ty_mdevè“ç‰™ä¿¡æ ‡,è¯·æ£€æŸ¥
                      }else if(rssi == 0x01) {
                          //æ¨¡å—æœªæˆæƒ
                      }
                  }else if(result == 0x01) {
                      //æµ‹è¯•æˆåŠŸ
                      //rssiä¸ºä¿¡å·å¼ºåº¦(0-100, 0ä¿¡å·æœ€å·®ï¼Œ100ä¿¡å·æœ€å¼º)
                  }
              }
              #endif
1194          
1195          #ifdef VOICE_MODULE_PROTOCOL_ENABLE
              /**
               * @brief  è·å–è¯­éŸ³çŠ¶æ€ç ç»“æœ
               * @param[in] {result} è¯­éŸ³çŠ¶æ€ç 
               * @ref       0x00: ç©ºé—²
               * @ref       0x01: micé™éŸ³çŠ¶æ€
               * @ref       0x02: å”¤é†’
               * @ref       0x03: æ­£åœ¨å½•éŸ³
               * @ref       0x04: æ­£åœ¨è¯†åˆ«
               * @ref       0x05: è¯†åˆ«æˆåŠŸ
               * @ref       0x06: è¯†åˆ«å¤±è´¥
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_voice_state_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è·å–è¯­éŸ³çŠ¶æ€ç ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0:
                          //ç©ºé—²
                      break;
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 21  

                  
                      case 1:
                          //micé™éŸ³çŠ¶æ€
                      break;
                      
                      case 2:
                          //å”¤é†’
                      break;
                      
                      case 3:
                          //æ­£åœ¨å½•éŸ³
                      break;
                      
                      case 4:
                          //æ­£åœ¨è¯†åˆ«
                      break;
                  
                      case 5:
                          //è¯†åˆ«æˆåŠŸ
                      break;
                      
                      case 6:
                          //è¯†åˆ«å¤±è´¥
                      break;
                      
                    default:break;
                  }
              }
              
              /**
               * @brief  MICé™éŸ³è®¾ç½®ç»“æœ
               * @param[in] {result} è¯­éŸ³çŠ¶æ€ç 
               * @ref       0x00: mic å¼€å¯
               * @ref       0x01: mic é™éŸ³
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void set_voice_MIC_silence_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°MICé™éŸ³è®¾ç½®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0) {
                      //mic å¼€å¯
                  }else {
                      //mic é™éŸ³
                  }
              }
              
              /**
               * @brief  speakeréŸ³é‡è®¾ç½®ç»“æœ
               * @param[in] {result} éŸ³é‡å€¼
               * @ref       0~10: éŸ³é‡èŒƒå›´
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void set_speaker_voice_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°speakeréŸ³é‡è®¾ç½®ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  
              }
              
              /**
               * @brief  éŸ³é¢‘äº§æµ‹ç»“æœ
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 22  

               * @param[in] {result} éŸ³é¢‘äº§æµ‹çŠ¶æ€
               * @ref       0x00: å…³é—­éŸ³é¢‘äº§æµ‹
               * @ref       0x01: mic1éŸ³é¢‘ç¯è·¯æµ‹è¯•
               * @ref       0x02: mic2éŸ³é¢‘ç¯è·¯æµ‹è¯•
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°éŸ³é¢‘äº§æµ‹ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0x00) {
                      //å…³é—­éŸ³é¢‘äº§æµ‹
                  }else if(result == 0x01) {
                      //mic1éŸ³é¢‘ç¯è·¯æµ‹è¯•
                  }else if(result == 0x02) {
                      //mic2éŸ³é¢‘ç¯è·¯æµ‹è¯•
                  }
              }
              
              /**
               * @brief  å”¤é†’äº§æµ‹ç»“æœ
               * @param[in] {result} å”¤é†’è¿”å›å€¼
               * @ref       0x00: å”¤é†’æˆåŠŸ
               * @ref       0x01: å”¤é†’å¤±è´¥(10sè¶…æ—¶å¤±è´¥)
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_awaken_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°å”¤é†’äº§æµ‹ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0x00) {
                      //å”¤é†’æˆåŠŸ
                  }else if(result == 0x01) {
                      //å”¤é†’å¤±è´¥
                  }
              }
              
              /**
               * @brief  è¯­éŸ³æ¨¡ç»„æ‰©å±•åŠŸèƒ½
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_module_extend_fun(const unsigned char value[], unsigned short length)
              {
                  unsigned char sub_cmd = value[0];
                  unsigned char play;
                  unsigned char bt_play;
                  unsigned short send_len = 0;
                
                  switch(sub_cmd) {
                      case 0x00: { //å­å‘½ä»¤  MCUåŠŸèƒ½è®¾ç½®
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 23  

                          }
                      }
                      break;
                      
                      case 0x01: {  //å­å‘½ä»¤  çŠ¶æ€é€šçŸ¥
                          if(0x02 > length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          unsigned char play = 0xff;
                          unsigned char bt_play = 0xff;
                          
                          const char *str_buff = (const char *)&value[1];
                          const char *str_result = NULL;
                          
                          str_result = strstr(str_buff,"play") + my_strlen("play") + 2;
                          if(NULL == str_result) {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          if(0 == memcmp(str_result, "true", my_strlen("true"))) {
                              play = 1;
                          }else if(0 == memcmp(str_result, "false", my_strlen("false"))) {
                              play = 0;
                          }else {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          str_result = strstr(str_buff,"bt_play") + my_strlen("bt_play") + 2;
                          if(NULL == str_result) {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          if(0 == memcmp(str_result, "true", my_strlen("true"))) {
                              bt_play = 1;
                          }else if(0 == memcmp(str_result, "false", my_strlen("false"))) {
                              bt_play = 0;
                          }else {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          #error "è¯·è‡ªè¡Œå®ç°è¯­éŸ³æ¨¡ç»„çŠ¶æ€é€šçŸ¥å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                          //MCUè®¾ç½®æš‚ä»…æ”¯æŒâ€æ’­æ”¾/æš‚åœâ€ â€è“ç‰™å¼€å…³â€
                          //play    æ’­æ”¾/æš‚åœåŠŸèƒ½  1(æ’­æ”¾) / 0(æš‚åœ)
                          //bt_play è“ç‰™å¼€å…³åŠŸèƒ½   1(å¼€)   / 0(å…³)
                          
                          
                          
                          send_len = 0;
                          send_len = set_wifi_uart_byte(send_len, sub_cmd);
                          send_len = set_wifi_uart_byte(send_len, 0x00);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
              
                      default:break;
                  }
C51 COMPILER V9.56.0.0   PROTOCOL                                                          11/07/2020 10:13:48 PAGE 24  

                  
                  return;
              
              ERR_EXTI:
                  send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, sub_cmd);
                  send_len = set_wifi_uart_byte(send_len, 0x01);
                  wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                  return;
              }
              #endif
1413          
1414          
1415          
1416          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    775    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =     20      21
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
