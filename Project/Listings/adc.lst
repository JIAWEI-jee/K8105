C51 COMPILER V9.56.0.0   ADC                                                               11/24/2020 14:40:58 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Objects\adc.obj
COMPILER INVOKED BY: C:\program_list\keil\C51\BIN\C51.EXE ..\hardware\ADC\adc.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..
                    -\hardware\DELAY;..\hardware\ADC;..\hardware\Flash;..\hardware\Uart;..\hardware\Key;..\hardware\Pwm;..\hardware\WDT;..\ha
                    -rdware\Timer;..\hardware\LCDdisplay;..\hardware\PID) DEBUG OBJECTEXTEND PRINT(.\Listings\adc.lst) TABS(2) OBJECT(.\Objec
                    -ts\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "delay.h"
   3          #include "flash.h"
   4          
   5          void adc_init ( void )
   6          {
   7   1        P0M3 = 0x01;    //P03设置为模拟输入
   8   1        P0M7 = 0x01;        //P07设置为模拟输入
   9   1        P0M2 = 0x01;        //P02设置为模拟输入
  10   1        ADCC0 = 0x81;   //打开ADC转换电源      4V为内部参考电压
  11   1        //00 VDD
  12   1      //                      01 内部4V
  13   1      //                      10 内部3V
  14   1      //                      11 内部2V
  15   1      //1、 内部参考电压选择为 2V 时， VDD 电压须高于 2.7V；
  16   1      //    内部参考电压选择为 3V 时， VDD 电压须高于 3.5V；
  17   1      //    内部参考电压选择为 4V 时， VDD 电压须高于4.5V。
  18   1      //2、 系统进入掉电模式前，建议将 ADC 参考电压选择非 VDD，可以进一步降低系统功耗。
  19   1        delay_us ( 80 );            //延时20us，确保ADC系统稳定
  20   1      
  21   1      //  ADCC1 = 0x08;           //选择ADC通道8
  22   1        ADCC2 = 0x49;           //转换结果12位数据，数据右对齐，ADC时钟4分频 4M/4 = 1MHz
  23   1      }
  24          
  25          u16 get_adc_val_P07 ( void )
  26          {
  27   1        u16 adc_val = 0;
  28   1        ADCC1 = 0x07;           //选择ADC通道7
  29   1        ADCC0 |= 0x40;          //启动ADC转换
  30   1        while ( ! ( ADCC0&0x20 ) );     //等待ADC转换结束
  31   1        ADCC0 &=~ 0x20;         //清除标志位
  32   1        adc_val = ADCR;         //获取ADC的值
  33   1      //  delay_us ( 20 );
  34   1      //  ADCR = 0;
  35   1        return adc_val;
  36   1      }
  37          
  38          u16 get_adc_val_P03 ( void )
  39          {
  40   1        u16 adc_val = 0;
  41   1        ADCC1 = 0x03;           //选择ADC通道0
  42   1        ADCC0 |= 0x40;          //启动ADC转换
  43   1        while ( ! ( ADCC0&0x20 ) );     //等待ADC转换结束
  44   1        ADCC0 &=~ 0x20;         //清除标志位
  45   1        adc_val = ADCR;         //获取ADC的值
  46   1      //  delay_us ( 20 );
  47   1      //  ADCR = 0;
  48   1        return adc_val;
  49   1      }
  50          
  51          u16 get_adc_val_P02 ( void )
  52          {
C51 COMPILER V9.56.0.0   ADC                                                               11/24/2020 14:40:58 PAGE 2   

  53   1        u16 adc_val = 0;
  54   1        ADCC1 = 0x02;           //选择ADC通道2
  55   1        ADCC0 |= 0x40;          //启动ADC转换
  56   1        while ( ! ( ADCC0&0x20 ) );     //等待ADC转换结束
  57   1        ADCC0 &=~ 0x20;         //清除标志位
  58   1        adc_val = ADCR;         //获取ADC的值
  59   1      //  delay_us ( 20 );
  60   1      //  ADCR = 0;
  61   1        return adc_val;
  62   1      }
  63          
  64          void get_voltage ( u16* u1_voltage,u16* u3_voltage )
  65          {
  66   1        u32 temp = 0;
  67   1        u8  i = 0;
  68   1        
  69   1        for ( i=0; i<5; i++ )
  70   1        {
  71   2          temp+=get_adc_val_P03();
  72   2        }
  73   1        temp/=5;
  74   1        *u1_voltage = temp*4000/4095;
  75   1        
  76   1        delay_us ( 20 );
  77   1        temp = 0;
  78   1        for ( i=0; i<5; i++ )
  79   1        {
  80   2          temp+=get_adc_val_P07();
  81   2        }
  82   1        temp/=5;
  83   1        *u3_voltage = temp*4000/4095;
  84   1        
  85   1      }
  86          
  87          u16 Detection_Input_Voltage(void)
  88          {
  89   1         
  90   1        u32 tep = 0;
  91   1        u8 i = 0;
  92   1      
  93   1        for ( i = 0; i < 5; i++ )
  94   1        {
  95   2          tep += get_adc_val_P02();
  96   2        }
  97   1        tep /= 5;
  98   1        tep = tep*4000/4096;  //放大1000倍 保存小数点后三位 4096
  99   1      
 100   1        return tep;
 101   1      }
 102          
 103          //u16 get_voltage_val ( void )
 104          //{
 105          //  u32 tep = 0;
 106          //  u8 i = 0;
 107          //
 108          //  for ( i = 0; i < 5; i++ )
 109          //  {
 110          //    tep += get_adc_val();
 111          //  }
 112          //  tep /= 5;
 113          //  tep = tep*4000/4096;  //放大1000倍 保存小数点后三位 4096
 114          //  return tep;
C51 COMPILER V9.56.0.0   ADC                                                               11/24/2020 14:40:58 PAGE 3   

 115          //}
 116          
 117          
 118          
 119          
 120          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    551    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
