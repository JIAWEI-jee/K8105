C51 COMPILER V9.56.0.0   MAIN                                                              11/07/2020 10:13:46 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\program_list\keil\C51\BIN\C51.EXE ..\user\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\hardwa
                    -re\DELAY;..\hardware\ADC;..\hardware\Flash;..\hardware\Uart;..\hardware\Key;..\hardware\Pwm;..\hardware\WDT;..\hardware\
                    -Timer;..\hardware\LCDdisplay;..\hardware\PID;..\hardware\TUYA) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJ
                    -ECT(.\Objects\main.obj)

line level    source

   1          /**
   2          * ************************************************************************************
   3          * @Examle Version   K8104
   4          * @Demo Version   V1.00.00
   5          * @Date       2020.6。23
   6          * ************************************************************************************
   7          *
   8          **/
   9          
  10          #define ALLOCATE_EXTERN
  11          #include "HC89F3541.H"
  12          #include "delay.h"
  13          #include "adc.h"
  14          #include "flash.h"
  15          #include "key.h"
  16          #include "uart.h"
  17          #include "pwm.h"
  18          #include "wdt.h"
  19          #include "timer.h"
  20          #include "lcddisplay.h"
  21          #include "PID.h"
  22          #include "wifi.h"
  23          
  24          #define SKU 8105
  25          #define SOFT_VER "1.00.00"
  26          
  27          
  28          u16 adc_cnt = 0;
  29          u8  first_heat_std = 0;
  30          u8  error_std = 0;
  31          
  32          void Clock ( void );
  33          void Set_Temp ( void );
  34          //void Controll_Heat ( void );
  35          //void Protect ( void );
  36          void Detection_Input ( void );
  37          
  38          
  39          
  40          /***************************************************/
  41          /*
  42          函数名称；key_handle()
  43          函数功能：按键处理函数
  44          入口参数：null
  45          出口参数：null
  46          函数说明；处理按键返回的键值调整相应功能
  47          */
  48          /********************************************************/
  49          
  50          static void key_handle ( void )
  51          {
  52   1        u8 key_val = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/07/2020 10:13:46 PAGE 2   

  53   1      
  54   1        if ( error_std == 0 )
  55   1      
  56   1        {
  57   2          key_val = key_scan();
  58   2        }
  59   1        else
  60   1        {
  61   2          key_val = 0;
  62   2        }
  63   1        if ( ( key_val == KEY_1_PRES ) && ( calibration_std == 0 ) )
  64   1        {
  65   2          //KEY_printf ( " key_scan\r\n" );
  66   2          if ( get_device_state() == ON )
  67   2          {
  68   3            set_device_state ( OFF );
  69   3                  led_set_off(); 
  70   3      //      set_pwm ( 0 );
  71   3            heat_out = 0;
  72   3      
  73   3          }
  74   2          else
  75   2          {
  76   3            set_device_state ( ON );
  77   3            set_time_sec();
  78   3            set_correct_time ( flash_info.gap );
  79   3            Set_Temp ( );
  80   3            //  gm_printf ( " spid.iSetVal = %d \r\n",  spid.iSetVal);
  81   3            first_heat_std = 1;
  82   3            led_set_on();
  83   3          }
  84   2        }
  85   1        else if ( get_device_state() == ON )
  86   1        {
  87   2      
  88   2         if ( key_val == LED_STAY_ON )
  89   2          {
  90   3      //      KEY_printf ( " KEY_led_PRES\r\n" );
  91   3            led_set_on();
  92   3          }
  93   2      
  94   2      
  95   2          if ( key_val == KEY_2_PRES )
  96   2          {
  97   3             led_set_on();
  98   3      //      KEY_printf ( " KEY_2_PRES\r\n" );
  99   3            if ( flash_info.gap < GAP_H )
*** ERROR C202 IN LINE 99 OF ..\user\main.c: 'GAP_H': undefined identifier
 100   3            {
 101   4              flash_info.gap++;
 102   4      
 103   4            }
 104   3            else
 105   3            {
 106   4              flash_info.gap = GAP_1;
 107   4            }
 108   3      
 109   3      
 110   3            first_heat_std = 1;
 111   3            set_correct_time ( flash_info.gap );
 112   3            Set_Temp ( );
 113   3            //  gm_printf ( " spid.iSetVal = %d \r\n",  spid.iSetVal);
C51 COMPILER V9.56.0.0   MAIN                                                              11/07/2020 10:13:46 PAGE 3   

 114   3            lcd_display_gap ( flash_info.gap );
 115   3            //set_time_sec();
 116   3            flah_save_data();
 117   3          }
 118   2          else if ( key_val == KEY_3_PRES ) //??
 119   2          {
 120   3            led_set_on();
 121   3            if ( flash_info.timer < 0x05 )
 122   3            {
 123   4              flash_info.timer++;
 124   4            }
 125   3            else
 126   3            {
 127   4              flash_info.timer = TIMER_ON;
 128   4            }
 129   3            if ( flash_info.gap > GAP_1 )
 130   3            {
 131   4              if ( flash_info.timer == TIMER_ON )
 132   4              {
 133   5                On_stay = 2;
 134   5              }
 135   4              else if ( flash_info.timer > TIMER_2H )
 136   4              {
 137   5                Gap_protect_std = 2;
 138   5              }
 139   4            }
 140   3            //  KEY_printf ( "timer:%d \r\n", ( u16 ) flash_info.timer );
 141   3            lcd_display_time ( flash_info.timer );
 142   3            set_time_sec();
 143   3            flah_save_data();
 144   3          }
 145   2        }
 146   1      }
 147          
 148          
 149          u16 calibration_temperature ( u16 temper )
 150          {
 151   1        u8 temp1 = 0;
 152   1        if ( ( usart_rx_flag == 2 ) && ( calibration_std == 1 ) )
 153   1        {
 154   2          temp1 = ( u8 ) temper;
 155   2          usart_rx_flag = 0;
 156   2          flash_info.correct_std = 1;
 157   2          if ( temper_val > 15 )
 158   2          {
 159   3            if ( temper_val > temp1 )
 160   3            {
 161   4              flash_info.correct_value = temper_val - temp1;
 162   4              flash_info.correct_sign = 1;
 163   4            }
 164   3            else
 165   3            {
 166   4              flash_info.correct_value = temp1 - temper_val;
 167   4      
 168   4              hal_uart_putchar ( flash_info.correct_value );
 169   4              flash_info.correct_sign = 2;
 170   4            }
 171   3            if ( ( flash_info.correct_value < 2 ) || ( flash_info.correct_value > 20 ) )
 172   3            {
 173   4              flash_info.correct_value = 0;
 174   4              flash_info.correct_sign = 0;
 175   4            }
C51 COMPILER V9.56.0.0   MAIN                                                              11/07/2020 10:13:46 PAGE 4   

 176   3            flah_save_data();
 177   3            producte_send_cmd ( 0x02, 0x02 );
 178   3          }
 179   2        }
 180   1        if ( flash_info.correct_sign == 1 )
 181   1        {
 182   2          return ( ( u16 ) ( temper = temper + flash_info.correct_value ) );
 183   2        }
 184   1        else if ( flash_info.correct_sign == 2 )
 185   1        {
 186   2          return ( ( u16 ) ( temper = temper - flash_info.correct_value ) );
 187   2        }
 188   1        return ( ( u16 ) temper );
 189   1      
 190   1      }
 191          
 192          
 193          
 194          u16 temp_calc ( u16 uRt,u16 uRw )
 195          {
 196   1        u16 i = 0;
 197   1        u16 basi_tmp = 40;
 198   1      
 199   1        float u1 = 0;
 200   1        float u3 = 0;
 201   1        if ( uRt < 90 )
 202   1        {
 203   2          return 0xff;
 204   2        }
 205   1      
 206   1        u1 = ( float ) uRt/1000;
 207   1        u3 =  ( float ) uRw /1000;
 208   1        u1 = (  u3 - u1 ) / u1 * 750;
 209   1        if ( u1 < 0 )
 210   1        {
 211   2          return 0xff;
 212   2        }
 213   1      //  gm_printf ( "R = %f  \r\n",u1 );
 214   1      
 215   1      
 216   1        if ( u1 > Temperature_Value )
 217   1        {
 218   2          i = ( u1 - Temperature_Value ) /0.4;
 219   2          //gm_printf("over 40  i:%d \r\n",i);
 220   2          basi_tmp = basi_tmp + i;
 221   2        }
 222   1      
 223   1        else
 224   1        {
 225   2          i = ( Temperature_Value - u1 ) /0.4;
 226   2          //  gm_printf("under 40  i:%d \r\n",i);
 227   2          basi_tmp = basi_tmp - i;
 228   2        }
 229   1      
 230   1      //  gm_printf("basi_tmp:%d \r\n",basi_tmp);
 231   1        if ( flash_info.gap == GAP_3 )
 232   1        {
 233   2          basi_tmp = basi_tmp - 5;
 234   2        }
 235   1      
 236   1        return  basi_tmp;
 237   1      }
C51 COMPILER V9.56.0.0   MAIN                                                              11/07/2020 10:13:46 PAGE 5   

 238          
 239          
 240          /*********************************************************/
 241          /*
 242          函数名称；temperature_handle()
 243          函数功能：温度处理函数
 244          入口参数：null
 245          出口参数：null
 246          函数说明；根据ADC侦测到的值算出温度值，通过温度的值进行温度控制
 247          */
 248          /********************************************************/
 249          
 250          void temperature_handle ( void )
 251          {
 252   1        u16 temp = 0;
 253   1        u16 adc_val1 = 0,adc_val2 = 0;
 254   1      
 255   1        adc_cnt++;
 256   1      
 257   1        if ( adc_cnt >= 50000 )
 258   1        {
 259   2          adc_cnt = 0;
 260   2          get_voltage ( &adc_val1,&adc_val2 );
 261   2      
 262   2          //  KEY_printf ( "adv1 = %d adv2 =%d \r\n",adc_val1,adc_val2 );  //pjw set
 263   2          temp = temp_calc ( adc_val1, adc_val2 );
 264   2          //  KEY_printf ( "temp val:%d \r\n",temp );
 265   2          temp =  calibration_temperature ( temp );
 266   2          //  KEY_printf ( "%d \r\n",temp );
 267   2         // temp = 25;
 268   2          if ( adc_val1 > 90 )          //adc_val1 > 90
 269   2          {
 270   3            if ( get_device_state() == ON )
 271   3            {
 272   4              lcd_off ( ON );
 273   4              if ( first_heat_std == 1 )
 274   4              {
 275   5                first_heat_std = 0;
 276   5                if ( temp > 75 )
 277   5                {
 278   6                  Heat_start_std = 0;
 279   6                  heat_step = 0;
 280   6                  //  KEY_printf ( "first_heat_std heat_step = 0; \r\n" );  //pjw set
 281   6                }
 282   5                else
 283   5                {
 284   6                  Heat_start_std = 1;
 285   6                  heat_step = 1;
 286   6                  //  KEY_printf ( "first_heat_std heat_step = 1; \r\n" );  //pjw set
 287   6                }
 288   5              }
 289   4      
 290   4              spid.iCurVal = temp*10;
 291   4              PID_Operation ();
 292   4              lcd_display_time ( flash_info.timer );
 293   4              lcd_display_gap ( flash_info.gap );
 294   4              PWM_control ( flash_info.gap );
 295   4            }
 296   3            else
 297   3            {
 298   4      
 299   4              if ( calibration_std == 1 )
C51 COMPILER V9.56.0.0   MAIN                                                              11/07/2020 10:13:46 PAGE 6   

 300   4              {
 301   5      //          set_pwm ( 0 );
 302   5                heat_out = 0;
 303   5      
 304   5                lcd_clear_all();
 305   5      
 306   5                lcd_cailbration ();
 307   5              }
 308   4              else
 309   4              {
 310   5      
 311   5                lcd_off ( OFF );
 312   5      //          set_pwm ( 0 );
 313   5                heat_out = 0;
 314   5      
 315   5                lcd_clear_all();
 316   5      
 317   5              }
 318   4      
 319   4            }
 320   3            error_std = 0;
 321   3          }
 322   2          else
 323   2          {
 324   3      
 325   3            calibration_std = 0;
 326   3            lcd_off ( Error );
 327   3            lcd_error (  );
 328   3            error_std = 1;
 329   3          }
 330   2      
 331   2      
 332   2        }
 333   1      
 334   1      
 335   1      }
 336          
 337          
 338          
 339          
 340          
 341          
 342          
 343          
 344          void main()
 345          {
 346   1        Clock();
 347   1        uart_init();
 348   1        adc_init();
 349   1        EA = 1;
 350   1        time0_init ();            //打开总中断
 351   1        key_init();
 352   1        flash_init();
 353   1        PID_Init();
 354   1        pwm_init (  );
 355   1        wdt_init ( 2 );
 356   1        LCD_Init();
 357   1        lcd_display_On();
 358   1        delay_ms ( 1200 );
 359   1        lcd_display_time ( TIMER_OFF );
 360   1        lcd_display_gap ( GAP_7 );
 361   1        delay_ms ( 600 );
C51 COMPILER V9.56.0.0   MAIN                                                              11/07/2020 10:13:46 PAGE 7   

 362   1        led_set_off();
 363   1        lcd_clear_all ();
 364   1        Detection_Input();
 365   1        wifi_protocol_init();
 366   1        gm_printf ( "\r\n==================================\r\n" );
 367   1        gm_printf ( "sku:K%d \r\n", ( u16 ) SKU );
 368   1        gm_printf ( "soft version:%s \r\n",SOFT_VER );
 369   1        gm_printf ( "gap %d \r\n", ( u16 ) flash_info.gap );      //档位
 370   1        gm_printf ( "timer %d \r\n", ( u16 ) flash_info.timer );  // 定时
 371   1        gm_printf ( "Input_Voltage_std = %d\r\n",Input_Voltage_std ); //输入电压
 372   1        gm_printf ( "==================================\r\n" );
 373   1      
 374   1        while ( 1 )
 375   1        {
 376   2      
 377   2          wifi_uart_service();
 378   2          temperature_handle();
 379   2          key_handle ();
 380   2          if ( error_std == 0 )
 381   2          {
 382   3            Heat_Operation ( pwm_set );
 383   3          }
 384   2      
 385   2          clear_wdt();
 386   2      
 387   2        }
 388   1      }
 389          
 390          
 391          
 392          void Clock ( void )
 393          {
 394   1        /************************************系统初始化****************************************/
 395   1        CLKSWR = 0x51;            //选择内部高频RC为系统时钟，内部高频RC 2分频，Fosc=16MHz
 396   1        CLKDIV = 0x01;            //Fosc 1分频得到Fcpu，Fcpu=16MHz
 397   1      }
 398          
 399          
 400          /***************************************************/
 401          /*
 402          函数名称；Set_Temp()
 403          函数功能：设定目标温度
 404          入口参数：null
 405          出口参数：null
 406          函数说明；根据不同档位设定要加热到的目标温度
 407          */
 408          /********************************************************/
 409          
 410          void Set_Temp ( void )
 411          {
 412   1      
 413   1      
 414   1        switch ( flash_info.gap )
 415   1        {
 416   2          case GAP_WARM:
 417   2      
 418   2            break;
 419   2          case GAP_1:
 420   2            spid.iSetVal = GAP_1_temp*10;
 421   2            break;
 422   2          case GAP_2:
 423   2            spid.iSetVal = GAP_2_temp*10;
C51 COMPILER V9.56.0.0   MAIN                                                              11/07/2020 10:13:46 PAGE 8   

 424   2            break;
 425   2          case GAP_3:
 426   2            spid.iSetVal = GAP_3_temp*10;
 427   2            break;
 428   2          case GAP_4:
 429   2            spid.iSetVal = GAP_4_temp*10;
 430   2            break;
 431   2          case GAP_5:
 432   2            spid.iSetVal = GAP_5_temp*10;
 433   2            break;
 434   2          case GAP_6:
 435   2            spid.iSetVal = GAP_6_temp*10;
 436   2            break;
 437   2          case GAP_7:
 438   2            spid.iSetVal = GAP_7_temp*10;
 439   2            break;
 440   2          case GAP_8:
 441   2            spid.iSetVal = GAP_8_temp*10;
 442   2            break;
 443   2          case GAP_9:
 444   2            spid.iSetVal = GAP_9_temp*10;
 445   2            break;
 446   2        }
 447   1      }
 448          
 449          /*********************************************************/
 450          /*
 451          函数名称；Protect
 452          入口参数：null
 453          出口参数：null
 454          函数说明；大于Gap1档位情况下加热超过2小时会跳到Gap1
 455          */
 456          /********************************************************/
 457          //void Protect ( void )
 458          //{
 459          //  if ( over_rang_time_std == 1 )
 460          //  {
 461          //    if ( flash_info.gap > GAP_1 )
 462          //    {
 463          //      flash_info.gap = GAP_1;
 464          //      Set_Temp ( );
 465          //      flah_save_data();
 466          //      over_rang_time_std = 0;
 467          //    }
 468          //  }
 469          //}
 470          
 471          
 472          void Detection_Input ( void )
 473          {
 474   1        u16 input = 0;
 475   1        input = Detection_Input_Voltage( );
 476   1        if ( input > 1600 )
 477   1        {
 478   2          //gm_printf ( "input24 = %d\r\n" ,input); //输入电压
 479   2          Input_Voltage_std = V_24_status;
 480   2        }
 481   1        else
 482   1        {
 483   2          //gm_printf ( "input12 = %d\r\n" ,input); //输入电压
 484   2          Input_Voltage_std = V_12_status;
 485   2        }
C51 COMPILER V9.56.0.0   MAIN                                                              11/07/2020 10:13:46 PAGE 9   

 486   1      }
 487          

C51 COMPILATION COMPLETE.  0 WARNING(S),  1 ERROR(S)
